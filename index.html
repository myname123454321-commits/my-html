<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D æ‰‹åŠ¿äº¤äº’ç²’å­ç³»ç»Ÿ</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            font-family: 'Segoe UI', Roboto, sans-serif;
        }

        #canvas-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        /* --- ä¿®æ”¹å¤„ï¼šæ‘„åƒå¤´ç”»é¢å®¹å™¨ --- */
        /* æˆ‘ä»¬ç”¨ä¸€ä¸ªå®¹å™¨æ¥åŒ…è£¹ è§†é¢‘ å’Œ ç»˜åˆ¶éª¨éª¼çš„ç”»å¸ƒï¼Œæ–¹ä¾¿ç»Ÿä¸€ç®¡ç† */
        #camera-container {
            position: absolute;
            top: 20px;
            left: 20px;
            width: 320px;  /* å®½åº¦åŠ å¤§åˆ° 320px */
            height: 240px; /* é«˜åº¦åŠ å¤§åˆ° 240px */
            z-index: 20;
            border-radius: 12px;
            overflow: hidden; /* åœ†è§’è£åˆ‡ */
            border: 2px solid rgba(255, 255, 255, 0.3);
            box-shadow: 0 0 20px rgba(0,0,0,0.5); /* åŠ ç‚¹é˜´å½±æ›´ç«‹ä½“ */
            transform: scaleX(-1); /* æ•´ä½“é•œåƒç¿»è½¬ */
        }

        /* è§†é¢‘ç”»é¢ */
        .input_video {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            object-fit: cover;
        }

        /* éª¨éª¼ç»˜åˆ¶å±‚ (é€æ˜å åŠ åœ¨è§†é¢‘ä¸Š) */
        .output_canvas {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            /* åªè¦è¿™ä¸€å±‚è¦†ç›–åœ¨ video ä¸Šå³å¯ */
        }

        /* UI é¢æ¿æ ·å¼ */
        #ui-panel {
            position: absolute;
            top: 20px;
            right: 20px;
            z-index: 10;
            background: rgba(255, 255, 255, 0.15);
            backdrop-filter: blur(10px);
            padding: 20px;
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: white;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
            width: 220px;
        }

        .ui-group { margin-bottom: 15px; }
        .ui-label { display: block; margin-bottom: 8px; font-weight: 500; font-size: 14px;}

        /* æŒ‰é’®æ ·å¼ */
        .shape-btn {
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: white;
            padding: 8px 12px;
            margin: 4px;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s;
            font-size: 13px;
        }
        .shape-btn:hover { background: rgba(255, 255, 255, 0.2); }
        .shape-btn.active { background: #2563eb; border-color: #2563eb; }

        input[type="color"] {
            width: 100%; height: 35px; border: none; border-radius: 6px; cursor: pointer;
        }
        #fullscreen-btn {
            width: 100%; padding: 10px; background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.3); color: white; border-radius: 6px;
            cursor: pointer; margin-top: 10px;
        }
        #fullscreen-btn:hover { background: rgba(255, 255, 255, 0.2); }

        #loading {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: white; z-index: 20; font-size: 1.2rem; pointer-events: none;
            text-align: center; line-height: 1.6;
        }
    </style>
</head>
<body>
    <div id="loading">æ­£åœ¨å¯åŠ¨æ‘„åƒå¤´å’Œ AI æ¨¡å‹...<br>è¯·åœ¨å¼¹çª—ä¸­ç‚¹å‡»â€œå…è®¸â€</div>
    
    <div id="camera-container">
        <video class="input_video"></video>
        <canvas class="output_canvas"></canvas>
    </div>
    
    <div id="canvas-container"></div>

    <div id="ui-panel">
        <div class="ui-group">
            <label class="ui-label">é€‰æ‹©æ¨¡å‹å½¢çŠ¶</label>
            <button class="shape-btn active" data-shape="heart">çˆ±å¿ƒ â¤ï¸</button>
            <button class="shape-btn" data-shape="sphere">åœŸæ˜Ÿ(çƒä½“) ğŸª</button>
            <button class="shape-btn" data-shape="cube">æ–¹å— ğŸ§Š</button>
        </div>
        <div class="ui-group">
            <label class="ui-label">ç²’å­é¢œè‰²</label>
            <input type="color" id="color-picker" value="#ff4444">
        </div>
        <button id="fullscreen-btn">ğŸ“º åˆ‡æ¢å…¨å±</button>
        <p style="font-size: 12px; opacity: 0.7; margin-top: 15px;">æç¤ºï¼šæ‰‹éƒ¨éª¨éª¼å·²å¯è§†åŒ–ã€‚<br>æ¡æ‹³=èšåˆï¼Œå¼ å¼€=æ‰©æ•£ã€‚</p>
    </div>


<script>
    // ================= é…ç½®åŒºåŸŸ =================
    const PARTICLE_COUNT = 5000; 
    const PARTICLE_SIZE = 0.05;  
    let currentColor = 0xff4444; 
    let currentShape = 'heart';  

    // ================= Three.js åŸºç¡€è®¾ç½® =================
    const scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x000000, 0.02);
    
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.z = 5;

    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    document.getElementById('canvas-container').appendChild(renderer.domElement);

    // ================= ç²’å­ç³»ç»Ÿæ ¸å¿ƒ =================
    const shapes = {
        heart: new Float32Array(PARTICLE_COUNT * 3),
        sphere: new Float32Array(PARTICLE_COUNT * 3),
        cube: new Float32Array(PARTICLE_COUNT * 3)
    };

    function precomputeShapes() {
        const v3 = new THREE.Vector3();
        for (let i = 0; i < PARTICLE_COUNT; i++) {
            const i3 = i * 3;

            // 1. çˆ±å¿ƒ
            const t = Math.random() * Math.PI * 2;
            let x = 16 * Math.pow(Math.sin(t), 3);
            let y = 13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t);
            let z = (Math.random() - 0.5) * 4; 
            v3.set(x, y, z).multiplyScalar(0.15); 
            shapes.heart[i3] = v3.x; shapes.heart[i3+1] = v3.y; shapes.heart[i3+2] = v3.z;

            // 2. çƒä½“
            const phi = Math.acos(-1 + (2 * i) / PARTICLE_COUNT);
            const theta = Math.sqrt(PARTICLE_COUNT * Math.PI) * phi;
            v3.setFromSphericalCoords(2.5, phi, theta); 
            shapes.sphere[i3] = v3.x; shapes.sphere[i3+1] = v3.y; shapes.sphere[i3+2] = v3.z;

            // 3. æ–¹å—
            const boxSize = 4;
            v3.set(
                (Math.random() - 0.5) * boxSize,
                (Math.random() - 0.5) * boxSize,
                (Math.random() - 0.5) * boxSize
            );
            shapes.cube[i3] = v3.x; shapes.cube[i3+1] = v3.y; shapes.cube[i3+2] = v3.z;
        }
    }
    precomputeShapes();

    const geometry = new THREE.BufferGeometry();
    const positions = new Float32Array(PARTICLE_COUNT * 3);
    geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));

    const material = new THREE.PointsMaterial({
        color: currentColor,
        size: PARTICLE_SIZE,
        transparent: true,
        opacity: 0.8,
        blending: THREE.AdditiveBlending, 
        depthWrite: false
    });

    const particleSystem = new THREE.Points(geometry, material);
    scene.add(particleSystem);


    // ================= MediaPipe æ‰‹åŠ¿è¯†åˆ«ä¸ç»˜åˆ¶ =================
    let handOpenness = 0; 
    const videoElement = document.getElementsByClassName('input_video')[0];
    const canvasElement = document.getElementsByClassName('output_canvas')[0];
    const canvasCtx = canvasElement.getContext('2d');

    function onResults(results) {
        document.getElementById('loading').style.display = 'none';

        // 1. å‡†å¤‡ç”»å¸ƒ
        canvasElement.width = videoElement.videoWidth;
        canvasElement.height = videoElement.videoHeight;
        canvasCtx.save();
        canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);

        // 2. å¦‚æœæ£€æµ‹åˆ°æ‰‹
        if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
            const landmarks = results.multiHandLandmarks[0];
            
            // --- æ ¸å¿ƒä¿®æ”¹ï¼šç»˜åˆ¶éª¨éª¼ ---
            // ç»˜åˆ¶è¿æ¥çº¿ (ç»¿è‰²)
            drawConnectors(canvasCtx, landmarks, HAND_CONNECTIONS,
                            {color: '#00FF00', lineWidth: 4});
            // ç»˜åˆ¶å…³é”®ç‚¹ (çº¢è‰²)
            drawLandmarks(canvasCtx, landmarks,
                            {color: '#FF0000', lineWidth: 2, radius: 4});

            // --- è®¡ç®—å¼€åˆåº¦é€»è¾‘ ---
            const wrist = landmarks[0];
            const fingertips = [8, 12, 16, 20];
            let totalDistance = 0;
            
            fingertips.forEach(tipIndex => {
                const tip = landmarks[tipIndex];
                const dx = tip.x - wrist.x;
                const dy = tip.y - wrist.y;
                totalDistance += Math.sqrt(dx*dx + dy*dy);
            });
            
            const avgDistance = totalDistance / 4;
            handOpenness = Math.max(0, Math.min(1, (avgDistance - 0.15) * 2.5));
        } else {
             handOpenness = (handOpenness * 0.95) + (1 * 0.05);
        }
        canvasCtx.restore();
    }

    const hands = new Hands({locateFile: (file) => {
        return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
    }});
    hands.setOptions({
        maxNumHands: 1, 
        modelComplexity: 1,
        minDetectionConfidence: 0.5,
        minTrackingConfidence: 0.5
    });
    hands.onResults(onResults);

    const cameraUtils = new Camera(videoElement, {
        onFrame: async () => {
            await hands.send({image: videoElement});
        },
        width: 640,
        height: 480
    });
    cameraUtils.start();


    // ================= åŠ¨ç”»å¾ªç¯ & äº¤äº’é€»è¾‘ =================
    let smoothedOpenness = 1;

    function animate() {
        requestAnimationFrame(animate);
        smoothedOpenness += (handOpenness - smoothedOpenness) * 0.1;

        const currentPositions = geometry.attributes.position.array;
        const targetShapeData = shapes[currentShape];

        for (let i = 0; i < PARTICLE_COUNT; i++) {
            const i3 = i * 3;
            const tx = targetShapeData[i3];
            const ty = targetShapeData[i3 + 1];
            const tz = targetShapeData[i3 + 2];

            const dist = Math.sqrt(tx*tx + ty*ty + tz*tz) + 0.001; 
            const dirX = tx / dist;
            const dirY = ty / dist;
            const dirZ = tz / dist;

            const explodeFactor = smoothedOpenness * 5.0; 

            currentPositions[i3] = tx + dirX * explodeFactor * dist;
            currentPositions[i3 + 1] = ty + dirY * explodeFactor * dist;
            currentPositions[i3 + 2] = tz + dirZ * explodeFactor * dist;
        }
        geometry.attributes.position.needsUpdate = true;
        particleSystem.rotation.y += 0.002;
        particleSystem.rotation.x += 0.001;
        renderer.render(scene, camera);
    }
    animate();

    // ================= UI äº‹ä»¶ç›‘å¬ =================
    document.querySelectorAll('.shape-btn').forEach(btn => {
        btn.addEventListener('click', (e) => {
            document.querySelectorAll('.shape-btn').forEach(b => b.classList.remove('active'));
            e.target.classList.add('active');
            currentShape = e.target.dataset.shape;
        });
    });

    const colorPicker = document.getElementById('color-picker');
    colorPicker.addEventListener('input', (e) => {
        const hexColor = e.target.value;
        material.color.set(hexColor);
    });

    const fullscreenBtn = document.getElementById('fullscreen-btn');
    fullscreenBtn.addEventListener('click', () => {
        if (!document.fullscreenElement) {
            document.documentElement.requestFullscreen();
        } else {
            if (document.exitFullscreen) {
                document.exitFullscreen();
            }
        }
    });

    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });
</script>
</body>
</html>
