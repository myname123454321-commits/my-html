<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>åœ£è¯å¿«ä¹ - 3D ç²’å­ç‰¹æ•ˆ</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
    <link href="https://fonts.googleapis.com/css2?family=Ma+Shan+Zheng&display=swap" rel="stylesheet">

    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #050a14; /* æ·±é‚ƒå¤œç©ºé»‘ */
            font-family: 'Segoe UI', Roboto, sans-serif;
        }

        /* æ ‡é¢˜æ ·å¼ */
        #title-overlay {
            position: absolute;
            width: 100%;
            top: 15%;
            text-align: center;
            pointer-events: none;
            z-index: 5;
            transition: opacity 0.8s;
        }
        
        h1 {
            font-family: 'Ma Shan Zheng', cursive;
            color: #ffcc00;
            font-size: 6rem; /* è¶…å¤§å­—ä½“ */
            margin: 0;
            letter-spacing: 10px;
            text-shadow: 
                0 0 10px #ff0000,
                0 0 20px #ff6600,
                0 0 40px #ffcc00;
            animation: textGlow 2s ease-in-out infinite alternate;
        }

        @keyframes textGlow {
            from { text-shadow: 0 0 10px #ff0000, 0 0 20px #ffcc00; opacity: 0.9; }
            to { text-shadow: 0 0 20px #ff0000, 0 0 50px #ffcc00, 0 0 70px #ff0000; opacity: 1; }
        }

        #canvas-container {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%; z-index: 1;
        }

        /* æ‘„åƒå¤´å®¹å™¨ */
        #camera-container {
            position: absolute;
            top: 20px; left: 20px;
            width: 240px; height: 180px;
            z-index: 20;
            border-radius: 12px;
            overflow: hidden;
            border: 2px solid rgba(255, 215, 0, 0.4);
            box-shadow: 0 0 15px rgba(255, 215, 0, 0.2);
            transform: scaleX(-1);
            background: #000;
        }

        .input_video { position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover; opacity: 0.7; }
        .output_canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; }

        /* UI é¢æ¿ */
        #ui-panel {
            position: absolute; top: 20px; right: 20px; z-index: 10;
            background: rgba(20, 30, 48, 0.6);
            backdrop-filter: blur(8px);
            padding: 20px;
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            color: white;
            width: 200px;
            text-align: center;
        }

        .guide-text { font-size: 14px; margin-top: 10px; color: #ccc; line-height: 1.6; }
        .key { color: #ffd700; font-weight: bold; }

        #loading {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: #ffd700; z-index: 20; font-size: 1.5rem; pointer-events: none;
            text-align: center; line-height: 1.6; text-shadow: 0 0 10px black;
        }
    </style>
</head>
<body>
    <div id="loading">ğŸ„ æ­£åœ¨è£…é¥°åœ£è¯æ ‘...<br>è¯·å…è®¸æ‘„åƒå¤´æƒé™</div>

    <div id="title-overlay">
        <h1>åœ£è¯å¿«ä¹</h1>
    </div>
    
    <div id="camera-container">
        <video class="input_video"></video>
        <canvas class="output_canvas"></canvas>
    </div>
    
    <div id="canvas-container"></div>

    <div id="ui-panel">
        <div style="font-size: 1.2rem; font-weight: bold; color: #ffd700; margin-bottom: 10px;">æ“ä½œæŒ‡å—</div>
        <div class="guide-text">
            <span class="key">âœŠ æ¡æ‹³</span><br>å‡èšæˆç¼¤çº·åœ£è¯æ ‘
        </div>
        <div class="guide-text">
            <span class="key">âœ‹ å¼ å¼€</span><br>é‡Šæ”¾æ¼«å¤©æ˜Ÿå…‰
        </div>
    </div>

<script>
    // ================= é…ç½®åŒºåŸŸ =================
    const PARTICLE_COUNT = 15000; // ç²’å­æ•°é‡å¢åŠ åˆ° 15000ï¼Œæ ‘æ›´èŒ‚å¯†
    const PARTICLE_SIZE = 0.05;   
    let currentShape = 'tree';    

    // ================= Three.js åœºæ™¯ =================
    const scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x050a14, 0.025); // æ·±è“é›¾æ°”
    
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.z = 7;
    camera.position.y = 0.5;

    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    document.getElementById('canvas-container').appendChild(renderer.domElement);

    // ================= ğŸ„ æ ¸å¿ƒï¼šå¤šå½©åœ£è¯æ ‘ç®—æ³• =================
    const shapes = {
        tree: new Float32Array(PARTICLE_COUNT * 3),
    };

    // é¢œè‰²å®šä¹‰
    const colors = [];
    const colorPalette = [
        new THREE.Color('#2ecc71'), // ç»¿ (æ ‘å¶) - å  70%
        new THREE.Color('#27ae60'), // æ·±ç»¿ (æ ‘å¶é˜´å½±)
        new THREE.Color('#e74c3c'), // çº¢ (è£…é¥°çƒ)
        new THREE.Color('#f1c40f'), // é‡‘ (æ˜Ÿæ˜Ÿ/ç¯å…‰)
        new THREE.Color('#3498db'), // è“ (å½©ç¯)
        new THREE.Color('#9b59b6'), // ç´« (å½©ç¯)
        new THREE.Color('#ffffff')  // ç™½ (é›ªèŠ±)
    ];

    function precomputeShapes() {
        const v3 = new THREE.Vector3();
        
        for (let i = 0; i < PARTICLE_COUNT; i++) {
            const i3 = i * 3;

            // --- èºæ—‹åœ†é”¥æ ‘å½¢ç®—æ³• ---
            const t = i / PARTICLE_COUNT; // 0 åˆ° 1 (é«˜åº¦å½’ä¸€åŒ–)
            
            // èºæ—‹è§’åº¦ï¼šè¶Šå¾€ä¸‹åœˆè¶Šå¤§
            const angle = t * 120; 
            
            // é«˜åº¦ï¼šä» -3.5 åˆ° 3.5
            const y = (t * 7) - 3.5; 
            
            // åŠå¾„ï¼šåº•éƒ¨å®½ï¼Œé¡¶éƒ¨å°–ï¼Œå½¢æˆåœ†é”¥
            // åŠ å…¥éšæœºæ‰°åŠ¨ (Math.random()) è®©æ ‘æœ‰ä½“ç§¯æ„Ÿï¼Œä¸æ˜¯ç©ºå¿ƒçš„å£³
            const maxRadius = (1 - t) * 4.0; 
            const r = Math.random() * maxRadius; 
            
            const x = r * Math.cos(angle);
            const z = r * Math.sin(angle);

            shapes.tree[i3] = x;
            shapes.tree[i3+1] = y;
            shapes.tree[i3+2] = z;

            // --- é¢œè‰²åˆ†é…é€»è¾‘ ---
            let color;
            const rand = Math.random();

            if (rand < 0.6) {
                color = colorPalette[0]; // æµ…ç»¿
            } else if (rand < 0.85) {
                color = colorPalette[1]; // æ·±ç»¿
            } else if (rand < 0.89) {
                color = colorPalette[2]; // çº¢çƒ
            } else if (rand < 0.93) {
                color = colorPalette[3]; // é‡‘å…‰
            } else if (rand < 0.96) {
                color = colorPalette[4]; // è“ç¯
            } else if (rand < 0.98) {
                color = colorPalette[5]; // ç´«ç¯
            } else {
                color = colorPalette[6]; // ç™½é›ª
            }

            colors.push(color.r, color.g, color.b);
        }
    }
    precomputeShapes();

    // æ„å»ºå‡ ä½•ä½“
    const geometry = new THREE.BufferGeometry();
    const positions = new Float32Array(PARTICLE_COUNT * 3);
    // åˆå§‹ä½ç½®è®¾ä¸ºæ ‘çš„ä½ç½® (é»˜è®¤æ˜¾ç¤ºæ ‘)
    geometry.setAttribute('position', new THREE.BufferAttribute(shapes.tree, 3));
    geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));

    // æè´¨ï¼šä½¿ç”¨å†…ç½®çš„åœ†å½¢è´´å›¾ç”Ÿæˆå‡½æ•°ï¼Œä¸å†ä¾èµ–ç½‘ç»œå›¾ç‰‡
    function getTexture() {
        const canvas = document.createElement('canvas');
        canvas.width = 32; canvas.height = 32;
        const ctx = canvas.getContext('2d');
        const grad = ctx.createRadialGradient(16,16,0,16,16,16);
        grad.addColorStop(0, 'rgba(255,255,255,1)');
        grad.addColorStop(0.4, 'rgba(255,255,255,0.3)');
        grad.addColorStop(1, 'rgba(0,0,0,0)');
        ctx.fillStyle = grad;
        ctx.fillRect(0,0,32,32);
        const texture = new THREE.Texture(canvas);
        texture.needsUpdate = true;
        return texture;
    }

    const material = new THREE.PointsMaterial({
        size: PARTICLE_SIZE * 3.5, // ç¨å¾®è°ƒå¤§ä¸€ç‚¹ï¼Œçœ‹èµ·æ¥æ›´äº®
        map: getTexture(),
        vertexColors: true, // å¯ç”¨é¡¶ç‚¹é¢œè‰²
        transparent: true,
        opacity: 0.9,
        blending: THREE.AdditiveBlending, // å‘å…‰å åŠ 
        depthWrite: false
    });

    const particleSystem = new THREE.Points(geometry, material);
    scene.add(particleSystem);

    // ================= MediaPipe æ‰‹åŠ¿è¯†åˆ« =================
    let handOpenness = 0; 
    const videoElement = document.getElementsByClassName('input_video')[0];
    const canvasElement = document.getElementsByClassName('output_canvas')[0];
    const canvasCtx = canvasElement.getContext('2d');

    function onResults(results) {
        document.getElementById('loading').style.display = 'none';

        // ç»˜åˆ¶éª¨éª¼
        canvasElement.width = videoElement.videoWidth;
        canvasElement.height = videoElement.videoHeight;
        canvasCtx.save();
        canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);

        if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
            const landmarks = results.multiHandLandmarks[0];
            
            // éª¨éª¼é¢œè‰²
            drawConnectors(canvasCtx, landmarks, HAND_CONNECTIONS, {color: '#2ecc71', lineWidth: 2});
            drawLandmarks(canvasCtx, landmarks, {color: '#f1c40f', lineWidth: 1, radius: 2});

            // è®¡ç®—å¼€åˆåº¦
            const wrist = landmarks[0];
            const fingertips = [8, 12, 16, 20];
            let totalDistance = 0;
            fingertips.forEach(tipIndex => {
                const tip = landmarks[tipIndex];
                const dx = tip.x - wrist.x;
                const dy = tip.y - wrist.y;
                totalDistance += Math.sqrt(dx*dx + dy*dy);
            });
            const avgDistance = totalDistance / 4;
            // æ˜ å°„åˆ° 0-1
            handOpenness = Math.max(0, Math.min(1, (avgDistance - 0.15) * 2.5));
        } else {
             // æ²¡æ‰‹æ—¶è‡ªåŠ¨å½’ä½
             handOpenness = (handOpenness * 0.92);
        }
        canvasCtx.restore();
    }

    const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
    hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });
    hands.onResults(onResults);

    const cameraUtils = new Camera(videoElement, {
        onFrame: async () => { await hands.send({image: videoElement}); },
        width: 640, height: 480
    });
    cameraUtils.start();

    // ================= åŠ¨ç”»å¾ªç¯ =================
    let smoothedOpenness = 0;

    function animate() {
        requestAnimationFrame(animate);
        
        // ç¼“åŠ¨
        smoothedOpenness += (handOpenness - smoothedOpenness) * 0.08;

        const currentPositions = geometry.attributes.position.array;
        const targetTree = shapes.tree;
        
        // çˆ†ç‚¸æ‰©æ•£ç³»æ•° (æ‰‹å¼ å¼€è¶Šå¤§ï¼Œç³»æ•°è¶Šå¤§)
        const explodeFactor = smoothedOpenness * 8.0; 

        // ç²’å­æ›´æ–°
        for (let i = 0; i < PARTICLE_COUNT; i++) {
            const i3 = i * 3;
            const tx = targetTree[i3];
            const ty = targetTree[i3 + 1];
            const tz = targetTree[i3 + 2];

            // åŸå§‹è·ç¦»
            const dist = Math.sqrt(tx*tx + ty*ty + tz*tz) + 0.01;
            const dirX = tx / dist;
            const dirY = ty / dist;
            const dirZ = tz / dist;
            
            // åŠ¨æ€å™ªç‚¹ï¼Œè®©é™æ­¢çš„æ ‘ä¹Ÿæœ‰å¾®å¾®å‘¼å¸çš„æ„Ÿè§‰ï¼Œç‚¸å¼€æ—¶æ›´æœ‰åŠ¨æ„Ÿ
            const time = Date.now() * 0.001;
            const noise = Math.sin(time + i) * (0.05 + smoothedOpenness * 0.2);

            // ç›®æ ‡ä½ç½® = åŸå§‹æ ‘ä½ç½® + (æ–¹å‘ * æ‰©æ•£ç³»æ•°)
            const targetX = tx + dirX * explodeFactor * dist + noise;
            const targetY = ty + dirY * explodeFactor * dist + noise;
            const targetZ = tz + dirZ * explodeFactor * dist + noise;

            // çº¿æ€§æ’å€¼ç§»åŠ¨
            currentPositions[i3] += (targetX - currentPositions[i3]) * 0.15;
            currentPositions[i3 + 1] += (targetY - currentPositions[i3 + 1]) * 0.15;
            currentPositions[i3 + 2] += (targetZ - currentPositions[i3 + 2]) * 0.15;
        }
        geometry.attributes.position.needsUpdate = true;
        
        // æ—‹è½¬
        // æ‰‹å¼ å¼€æ—¶è½¬å¾—æ…¢ï¼Œæ¡æ‹³æˆæ ‘æ—¶è½¬å¾—å¿«ä¸€ç‚¹å±•ç¤ºç»†èŠ‚
        particleSystem.rotation.y += 0.003 + (1 - smoothedOpenness) * 0.002;

        // æ ‡é¢˜æ·¡å‡ºé€»è¾‘ (æ‰‹å¼ å¼€æ—¶æ ‡é¢˜å˜æ·¡ï¼Œä¸“å¿ƒçœ‹ç²’å­)
        const titleEl = document.getElementById('title-overlay');
        titleEl.style.opacity = 1 - smoothedOpenness * 0.8;
        titleEl.style.transform = `scale(${1 + smoothedOpenness * 0.2})`;

        renderer.render(scene, camera);
    }
    animate();

    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });
</script>
</body>
</html>
