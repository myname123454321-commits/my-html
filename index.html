<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D åœ£è¯ç²’å­æ‰‹åŠ¿äº¤äº’</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #0d1b2a; /* æ·±å¤œè“èƒŒæ™¯ */
            font-family: 'Segoe UI', Roboto, sans-serif;
        }

        #canvas-container {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%; z-index: 1;
        }

        /* æ‘„åƒå¤´å®¹å™¨ */
        #camera-container {
            position: absolute;
            top: 20px; left: 20px;
            width: 320px; height: 240px;
            z-index: 20;
            border-radius: 12px;
            overflow: hidden;
            border: 2px solid rgba(255, 215, 0, 0.5); /* é‡‘è‰²è¾¹æ¡† */
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.2);
            transform: scaleX(-1);
        }

        .input_video { position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover; }
        .output_canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; }

        /* UI é¢æ¿ */
        #ui-panel {
            position: absolute; top: 20px; right: 20px; z-index: 10;
            background: rgba(20, 30, 48, 0.8);
            backdrop-filter: blur(10px);
            padding: 20px;
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            color: white;
            box-shadow: 0 4px 15px rgba(0,0,0,0.5);
            width: 220px;
        }

        .ui-label { display: block; margin-bottom: 8px; font-weight: 500; font-size: 14px; color: #ffd700; }
        
        .shape-btn {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: white;
            padding: 10px 12px;
            margin: 4px;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
            font-size: 14px;
            width: 100%;
            text-align: left;
        }
        .shape-btn:hover { background: rgba(255, 255, 255, 0.2); }
        .shape-btn.active { 
            background: linear-gradient(90deg, #16a085, #2ecc71); 
            border-color: #2ecc71; 
            font-weight: bold;
        }

        input[type="color"] { width: 100%; height: 35px; border: none; border-radius: 6px; cursor: pointer; margin-bottom: 15px; }
        
        #fullscreen-btn {
            width: 100%; padding: 10px; 
            background: #e74c3c; 
            border: none; color: white; border-radius: 6px;
            cursor: pointer; margin-top: 5px; font-weight: bold;
        }
        #fullscreen-btn:hover { background: #c0392b; }

        #loading {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: #ffd700; z-index: 20; font-size: 1.2rem; pointer-events: none;
            text-align: center; line-height: 1.6; text-shadow: 0 0 10px black;
        }
    </style>
</head>
<body>
    <div id="loading">ğŸ æ­£åœ¨å‡†å¤‡åœ£è¯ç¤¼ç‰©...<br>è¯·å…è®¸æ‘„åƒå¤´æƒé™</div>
    
    <div id="camera-container">
        <video class="input_video"></video>
        <canvas class="output_canvas"></canvas>
    </div>
    
    <div id="canvas-container"></div>

    <div id="ui-panel">
        <div class="ui-group">
            <label class="ui-label">ğŸ„ åœ£è¯æ¨¡å‹åº“</label>
            <button class="shape-btn active" data-shape="tree" data-color="#2ecc71">ğŸ„ åœ£è¯æ ‘ (Tree)</button>
            <button class="shape-btn" data-shape="star" data-color="#f1c40f">â­ ä¼¯åˆ©æ’ä¹‹æ˜Ÿ (Star)</button>
            <button class="shape-btn" data-shape="gift" data-color="#e74c3c">ğŸ ç¥ç§˜ç¤¼ç‰© (Gift)</button>
        </div>
        <div class="ui-group">
            <label class="ui-label" style="margin-top:15px">ğŸ¨ æ°›å›´ç¯å…‰ (ç²’å­é¢œè‰²)</label>
            <input type="color" id="color-picker" value="#2ecc71">
        </div>
        <button id="fullscreen-btn">ğŸ“º å…¨å±æ²‰æµ¸ä½“éªŒ</button>
        <p style="font-size: 12px; opacity: 0.7; margin-top: 15px; text-align: center;">
            âœ‹ å¼ å¼€æ‰‹ = é­”æ³•é‡Šæ”¾ (æ‰©æ•£)<br>âœŠ æ¡ç´§æ‹³ = å‡èšæˆå½¢
        </p>
    </div>

<script>
    // ================= é…ç½®åŒºåŸŸ =================
    const PARTICLE_COUNT = 8000; // å¢åŠ ç²’å­æ•°é‡è®©æ ‘æ›´èŒ‚å¯†
    const PARTICLE_SIZE = 0.04;  
    let currentColor = 0x2ecc71; // é»˜è®¤ç»¿è‰²
    let currentShape = 'tree';   

    // ================= Three.js åœºæ™¯ =================
    const scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x0d1b2a, 0.03); // é…åˆèƒŒæ™¯è‰²çš„é›¾
    
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.z = 4.5;
    camera.position.y = 0.5; // ç¨å¾®æŠ¬é«˜è§†è§’

    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    document.getElementById('canvas-container').appendChild(renderer.domElement);

    // ================= ğŸ„ æ ¸å¿ƒï¼šç²’å­å½¢çŠ¶ç®—æ³• =================
    const shapes = {
        tree: new Float32Array(PARTICLE_COUNT * 3),
        star: new Float32Array(PARTICLE_COUNT * 3),
        gift: new Float32Array(PARTICLE_COUNT * 3)
    };

    function precomputeShapes() {
        const v3 = new THREE.Vector3();
        
        for (let i = 0; i < PARTICLE_COUNT; i++) {
            const i3 = i * 3;

            // --- 1. åœ£è¯æ ‘ (Tree) ---
            // é€»è¾‘ï¼šåœ†é”¥ä½“æ ‘å†  + åœ†æŸ±ä½“æ ‘å¹²
            const isTrunk = i > PARTICLE_COUNT * 0.85; // 15% çš„ç²’å­åšæ ‘å¹²
            
            if (isTrunk) {
                // æ ‘å¹²ï¼šåœ†æŸ±ä½“
                const theta = Math.random() * Math.PI * 2;
                const r = Math.random() * 0.3; // æ ‘å¹²åŠå¾„
                const y = Math.random() * 1.5 - 2.5; // åº•éƒ¨é«˜åº¦
                v3.set(r * Math.cos(theta), y, r * Math.sin(theta));
            } else {
                // æ ‘å† ï¼šèºæ—‹åœ†é”¥
                // ä½¿ç”¨èºæ—‹ç®—æ³•è®©ç²’å­åˆ†å¸ƒæ›´å‡åŒ€å¥½çœ‹
                const t = i / (PARTICLE_COUNT * 0.85); // 0 åˆ° 1
                const y = t * 4 - 1.5; // é«˜åº¦èŒƒå›´
                // åŠå¾„éšé«˜åº¦å‡å° (2.5 - y) æ˜¯çº¿æ€§å˜ç»†ï¼ŒåŠ  Math.random() åšä½“ç§¯å¡«å……
                const maxRadius = (2.5 - y) * 0.6; 
                const r = Math.random() * maxRadius; 
                const theta = t * 50; // èºæ—‹è§’åº¦
                
                v3.set(r * Math.cos(theta), y, r * Math.sin(theta));
            }
            shapes.tree[i3] = v3.x; shapes.tree[i3+1] = v3.y; shapes.tree[i3+2] = v3.z;

            // --- 2. ä¼¯åˆ©æ’ä¹‹æ˜Ÿ (Star) ---
            // ç®€å•çš„äº”è§’æ˜Ÿä½“é€»è¾‘ (çƒä½“å˜ç§ï¼ŒæŒ¤å‹æŸäº›è§’åº¦)
            const phi = Math.acos(-1 + (2 * i) / PARTICLE_COUNT);
            const theta = Math.sqrt(PARTICLE_COUNT * Math.PI) * phi;
            
            // åˆ¶é€ â€œåˆºâ€çš„æ•ˆæœ
            const starSpike = 1 + 0.5 * Math.sin(theta * 5) * Math.sin(phi * 5);
            v3.setFromSphericalCoords(1.5 * starSpike, phi, theta);
            
            shapes.star[i3] = v3.x; shapes.star[i3+1] = v3.y; shapes.star[i3+2] = v3.z;

            // --- 3. ç¤¼ç‰©ç›’ (Gift / Cube) ---
            // æ–¹å—ï¼Œç¨å¾®ç´§å‡‘ä¸€ç‚¹
            const boxSize = 3;
            v3.set(
                (Math.random() - 0.5) * boxSize,
                (Math.random() - 0.5) * boxSize,
                (Math.random() - 0.5) * boxSize
            );
            shapes.gift[i3] = v3.x; shapes.gift[i3+1] = v3.y; shapes.gift[i3+2] = v3.z;
        }
    }
    precomputeShapes();

    // æ„å»ºå‡ ä½•ä½“
    const geometry = new THREE.BufferGeometry();
    const positions = new Float32Array(PARTICLE_COUNT * 3);
    geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));

    // æè´¨ï¼šä½¿ç”¨åŠ æ³•æ··åˆè®©ç²’å­å‘å…‰
    const material = new THREE.PointsMaterial({
        color: currentColor,
        size: PARTICLE_SIZE,
        transparent: true,
        opacity: 0.8,
        blending: THREE.AdditiveBlending,
        depthWrite: false
    });

    const particleSystem = new THREE.Points(geometry, material);
    scene.add(particleSystem);

    // ================= MediaPipe æ‰‹åŠ¿è¯†åˆ« =================
    let handOpenness = 0; 
    const videoElement = document.getElementsByClassName('input_video')[0];
    const canvasElement = document.getElementsByClassName('output_canvas')[0];
    const canvasCtx = canvasElement.getContext('2d');

    function onResults(results) {
        document.getElementById('loading').style.display = 'none';

        // ç»˜åˆ¶éª¨éª¼
        canvasElement.width = videoElement.videoWidth;
        canvasElement.height = videoElement.videoHeight;
        canvasCtx.save();
        canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);

        if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
            const landmarks = results.multiHandLandmarks[0];
            
            // åœ£è¯ç‰¹åˆ«ç‰ˆéª¨éª¼é¢œè‰²ï¼šçº¢ç»¿é…
            drawConnectors(canvasCtx, landmarks, HAND_CONNECTIONS, {color: '#00FF00', lineWidth: 4});
            drawLandmarks(canvasCtx, landmarks, {color: '#FF0000', lineWidth: 2, radius: 4});

            // è®¡ç®—å¼€åˆåº¦
            const wrist = landmarks[0];
            const fingertips = [8, 12, 16, 20];
            let totalDistance = 0;
            fingertips.forEach(tipIndex => {
                const tip = landmarks[tipIndex];
                totalDistance += Math.sqrt(Math.pow(tip.x - wrist.x, 2) + Math.pow(tip.y - wrist.y, 2));
            });
            const avgDistance = totalDistance / 4;
            handOpenness = Math.max(0, Math.min(1, (avgDistance - 0.15) * 2.5));
        } else {
             // æ²¡æ‰‹æ—¶è‡ªåŠ¨å½’ä½
             handOpenness = (handOpenness * 0.95);
        }
        canvasCtx.restore();
    }

    const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
    hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });
    hands.onResults(onResults);

    const cameraUtils = new Camera(videoElement, {
        onFrame: async () => { await hands.send({image: videoElement}); },
        width: 640, height: 480
    });
    cameraUtils.start();

    // ================= åŠ¨ç”»å¾ªç¯ =================
    let smoothedOpenness = 1;
    const colorObject = new THREE.Color();

    function animate() {
        requestAnimationFrame(animate);
        
        // ç¼“åŠ¨
        smoothedOpenness += (handOpenness - smoothedOpenness) * 0.1;
        
        // é¢œè‰²å¹³æ»‘è¿‡æ¸¡
        colorObject.setHex(currentColor);
        material.color.lerp(colorObject, 0.05);

        const currentPositions = geometry.attributes.position.array;
        const targetShapeData = shapes[currentShape];

        // ç²’å­æ›´æ–°
        for (let i = 0; i < PARTICLE_COUNT; i++) {
            const i3 = i * 3;
            const tx = targetShapeData[i3];
            const ty = targetShapeData[i3 + 1];
            const tz = targetShapeData[i3 + 2];

            const dist = Math.sqrt(tx*tx + ty*ty + tz*tz) + 0.01;
            const dirX = tx / dist;
            const dirY = ty / dist;
            const dirZ = tz / dist;

            // åœ£è¯æ ‘ç‰¹æ•ˆï¼šå¼ å¼€æ‰‹æ—¶ï¼Œç²’å­ä¸ä»…æ‰©æ•£ï¼Œè¿˜å¸¦ä¸€ç‚¹æ—‹è½¬é£èˆ
            const explodeFactor = smoothedOpenness * 6.0; 
            
            // ç®€å•çš„å™ªç‚¹åç§»ï¼Œè®©ç‚¸å¼€æ›´è‡ªç„¶
            const noise = Math.sin(Date.now() * 0.001 + i) * 0.2 * smoothedOpenness;

            currentPositions[i3] = tx + dirX * explodeFactor * dist + noise;
            currentPositions[i3 + 1] = ty + dirY * explodeFactor * dist + noise;
            currentPositions[i3 + 2] = tz + dirZ * explodeFactor * dist + noise;
        }
        geometry.attributes.position.needsUpdate = true;
        
        // æ—‹è½¬
        particleSystem.rotation.y += 0.003;
        // å¦‚æœæ˜¯æ ‘ï¼Œç¨å¾®æ…¢ä¸€ç‚¹è½¬Xè½´ï¼Œä¿æŒç›´ç«‹æ„Ÿ
        particleSystem.rotation.x = Math.sin(Date.now() * 0.0005) * 0.1; 

        renderer.render(scene, camera);
    }
    animate();

    // ================= äº¤äº’äº‹ä»¶ =================
    const colorPicker = document.getElementById('color-picker');

    document.querySelectorAll('.shape-btn').forEach(btn => {
        btn.addEventListener('click', (e) => {
            // æŒ‰é’®æ ·å¼æ›´æ–°
            document.querySelectorAll('.shape-btn').forEach(b => b.classList.remove('active'));
            e.target.classList.add('active');
            
            // åˆ‡æ¢å½¢çŠ¶
            currentShape = e.target.dataset.shape;
            
            // è‡ªåŠ¨åˆ‡æ¢åˆ°æ¨èé¢œè‰² (ä¾‹å¦‚ç‚¹æ ‘å˜æˆç»¿è‰²ï¼Œç‚¹ç¤¼ç‰©å˜æˆçº¢è‰²)
            const recommendColor = e.target.dataset.color;
            if(recommendColor) {
                currentColor = parseInt(recommendColor.replace('#', '0x'));
                colorPicker.value = recommendColor;
            }
        });
    });

    colorPicker.addEventListener('input', (e) => {
        currentColor = parseInt(e.target.value.replace('#', '0x'));
    });

    document.getElementById('fullscreen-btn').addEventListener('click', () => {
        if (!document.fullscreenElement) document.documentElement.requestFullscreen();
        else document.exitFullscreen();
    });

    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });
</script>
</body>
</html>
