<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>粒子圣诞树 - 纯净版</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
    <link href="https://fonts.googleapis.com/css2?family=Ma+Shan+Zheng&display=swap" rel="stylesheet">

    <style>
        body { margin: 0; overflow: hidden; background-color: #02050a; font-family: 'Segoe UI', sans-serif; }
        
        #title-overlay {
            position: absolute; width: 100%; top: 15%; text-align: center; pointer-events: none; z-index: 5;
            transition: opacity 1s;
        }
        h1 {
            font-family: 'Ma Shan Zheng', cursive; 
            color: #ffd700; 
            font-size: 6rem; 
            margin: 0;
            letter-spacing: 8px;
            text-shadow: 0 0 10px #ff0000, 0 0 30px #ffd700;
            animation: glow 3s ease-in-out infinite alternate;
        }
        @keyframes glow { from { opacity: 0.9; text-shadow: 0 0 10px #ff0000; } to { opacity: 1; text-shadow: 0 0 30px #ffd700, 0 0 60px #ff0000; } }

        #camera-container {
            position: absolute; top: 20px; left: 20px; width: 240px; height: 180px; z-index: 20;
            border-radius: 12px; overflow: hidden; border: 2px solid rgba(255, 215, 0, 0.4);
            box-shadow: 0 0 15px rgba(255, 215, 0, 0.1); transform: scaleX(-1);
            background: #000;
        }
        .input_video { position: absolute; width: 100%; height: 100%; object-fit: cover; opacity: 0.8; }
        .output_canvas { position: absolute; width: 100%; height: 100%; }

        #guide-panel {
            position: absolute; bottom: 40px; width: 100%; text-align: center; color: rgba(255,255,255,0.6); z-index: 10;
            pointer-events: none; font-size: 1rem; letter-spacing: 2px;
        }
        .key { color: #ffd700; font-weight: bold; margin: 0 8px; }

        #canvas-container { width: 100%; height: 100%; position: absolute; top: 0; left: 0; }
        #loading { position: absolute; top: 50%; left: 50%; transform: translate(-50%,-50%); color: #ffd700; font-size: 1.5rem; z-index: 100; text-align: center; }
    </style>
</head>
<body>
    <div id="loading">✨ 正在凝聚星光...<br>请允许摄像头权限</div>

    <div id="title-overlay">
        <h1>圣诞快乐</h1>
    </div>

    <div id="camera-container">
        <video class="input_video"></video>
        <canvas class="output_canvas"></canvas>
    </div>

    <div id="guide-panel">
        <span class="key">✊ 握拳</span> 凝聚成树 &nbsp;&nbsp;&nbsp;&nbsp; 
        <span class="key">✋ 张开</span> 漫天星光
    </div>

    <div id="canvas-container"></div>

<script>
    // ================= 配置区域 =================
    // 增加粒子数量，让树更茂密
    const PARTICLE_COUNT = 12000; 
    
    // ================= 场景初始化 =================
    const scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x02050a, 0.025); // 雾气
    
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.z = 7;
    camera.position.y = 0; 

    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    document.getElementById('canvas-container').appendChild(renderer.domElement);

    // ================= 1. 高精度粒子树系统 =================
    const particlesGeometry = new THREE.BufferGeometry();
    const particlesPositions = new Float32Array(PARTICLE_COUNT * 3);
    const particlesColors = new Float32Array(PARTICLE_COUNT * 3);
    const particlesSizes = new Float32Array(PARTICLE_COUNT);
    
    // 存储树的原始形态坐标
    const treeOriginalPos = new Float32Array(PARTICLE_COUNT * 3);
    // 存储爆炸后的随机扩散方向
    const explosionDirs = new Float32Array(PARTICLE_COUNT * 3);
    
    const colorGreen = new THREE.Color('#2ecc71');
    const colorRed = new THREE.Color('#e74c3c');
    const colorGold = new THREE.Color('#f1c40f');
    const colorWhite = new THREE.Color('#ffffff');

    for (let i = 0; i < PARTICLE_COUNT; i++) {
        const i3 = i * 3;
        
        // --- 树形算法 (圆锥螺旋) ---
        const t = i / PARTICLE_COUNT; 
        const angle = t * 120; // 螺旋更紧密
        
        // 高度 y: -3.5 到 3.5
        const y = (t * 7) - 3.5; 
        // 半径 r: 底部宽，顶部尖，加随机扰动模拟树枝
        const maxRadius = (1 - t) * 4.0; 
        const r = Math.random() * maxRadius; 
        
        const x = r * Math.cos(angle);
        const z = r * Math.sin(angle);

        // 存入原始树位置
        treeOriginalPos[i3] = x;
        treeOriginalPos[i3+1] = y;
        treeOriginalPos[i3+2] = z;

        // 初始化当前位置 = 树位置
        particlesPositions[i3] = x;
        particlesPositions[i3+1] = y;
        particlesPositions[i3+2] = z;

        // 计算爆炸方向 (归一化向量)
        const len = Math.sqrt(x*x + y*y + z*z) + 0.01;
        explosionDirs[i3] = x / len;
        explosionDirs[i3+1] = y / len;
        explosionDirs[i3+2] = z / len;

        // --- 颜色分配 ---
        let color = colorGreen;
        let size = 0.04; 
        
        const rand = Math.random();
        if (rand > 0.88) { color = colorRed; size = 0.09; } // 红球
        else if (rand > 0.94) { color = colorGold; size = 0.12; } // 金星
        else if (rand > 0.98) { color = colorWhite; size = 0.07; } // 白雪点缀
        
        particlesColors[i3] = color.r;
        particlesColors[i3+1] = color.g;
        particlesColors[i3+2] = color.b;
        particlesSizes[i] = size;
    }

    particlesGeometry.setAttribute('position', new THREE.BufferAttribute(particlesPositions, 3));
    particlesGeometry.setAttribute('color', new THREE.BufferAttribute(particlesColors, 3));
    particlesGeometry.setAttribute('size', new THREE.BufferAttribute(particlesSizes, 1));

    // 高级闪烁材质
    const particleMaterial = new THREE.ShaderMaterial({
        uniforms: {
            time: { value: 0 },
            pointTexture: { value: new THREE.TextureLoader().load("https://assets.codepen.io/127738/dotTexture.png") }
        },
        vertexShader: `
            attribute float size;
            varying vec3 vColor;
            uniform float time;
            void main() {
                vColor = color;
                vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                
                // 呼吸闪烁：不同高度相位不同，产生流动感
                float blink = 0.7 + 0.5 * sin(time * 3.0 + position.y * 2.0);
                
                // 大小随距离衰减
                gl_PointSize = size * (350.0 / -mvPosition.z) * blink;
                gl_Position = projectionMatrix * mvPosition;
            }
        `,
        fragmentShader: `
            uniform sampler2D pointTexture;
            varying vec3 vColor;
            void main() {
                gl_FragColor = vec4(vColor, 1.0);
                gl_FragColor = gl_FragColor * texture2D(pointTexture, gl_PointCoord);
                if (gl_FragColor.a < 0.1) discard;
            }
        `,
        blending: THREE.AdditiveBlending,
        depthTest: false,
        transparent: true
    });

    const particleSystem = new THREE.Points(particlesGeometry, particleMaterial);
    scene.add(particleSystem);

    // ================= 2. 氛围飘雪 =================
    const snowGeo = new THREE.BufferGeometry();
    const snowCount = 1500;
    const snowPos = new Float32Array(snowCount * 3);
    for(let i=0; i<snowCount*3; i++) {
        snowPos[i] = (Math.random()-0.5) * 25;
    }
    snowGeo.setAttribute('position', new THREE.BufferAttribute(snowPos, 3));
    const snowMat = new THREE.PointsMaterial({color: 0xffffff, size: 0.04, transparent: true, opacity: 0.4});
    const snowSystem = new THREE.Points(snowGeo, snowMat);
    scene.add(snowSystem);

    // ================= 手势识别 =================
    let handOpenness = 0; 
    
    const videoElement = document.getElementsByClassName('input_video')[0];
    const canvasElement = document.getElementsByClassName('output_canvas')[0];
    const canvasCtx = canvasElement.getContext('2d');

    function onResults(results) {
        document.getElementById('loading').style.display = 'none';
        canvasElement.width = videoElement.videoWidth;
        canvasElement.height = videoElement.videoHeight;
        canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);

        if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
            const landmarks = results.multiHandLandmarks[0];
            
            // 绘制绿色骨骼线
            drawConnectors(canvasCtx, landmarks, HAND_CONNECTIONS, {color: '#2ecc71', lineWidth: 2});
            drawLandmarks(canvasCtx, landmarks, {color: '#f1c40f', lineWidth: 1, radius: 2});

            // 计算开合度
            const wrist = landmarks[0];
            const tips = [8, 12, 16, 20];
            let dist = 0;
            tips.forEach(i => dist += Math.hypot(landmarks[i].x - wrist.x, landmarks[i].y - wrist.y));
            // 映射到 0~1
            handOpenness = Math.max(0, Math.min(1, (dist/4 - 0.15) * 2.8));

        } else {
            // 无手势，自动闭合
            handOpenness *= 0.92;
        }
    }

    const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
    hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });
    hands.onResults(onResults);

    const cameraUtils = new Camera(videoElement, {
        onFrame: async () => { await hands.send({image: videoElement}); },
        width: 320, height: 240
    });
    cameraUtils.start();

    // ================= 动画循环 =================
    let smoothedOpenness = 0;
    
    function animate() {
        requestAnimationFrame(animate);

        const time = Date.now() * 0.001;
        particleMaterial.uniforms.time.value = time;
        
        // 缓动动画
        smoothedOpenness += (handOpenness - smoothedOpenness) * 0.08;

        const positions = particleSystem.geometry.attributes.position.array;
        
        // 爆炸系数 (张开手越大约大)
        const explosionFactor = smoothedOpenness * 8.0; 

        // 旋转树 (握拳时转得快，炸开时转得慢)
        const rotationSpeed = 0.005 * (1 - smoothedOpenness * 0.8);
        particleSystem.rotation.y += rotationSpeed;

        for (let i = 0; i < PARTICLE_COUNT; i++) {
            const i3 = i * 3;
            const ox = treeOriginalPos[i3];
            const oy = treeOriginalPos[i3+1];
            const oz = treeOriginalPos[i3+2];

            // 计算目标位置
            // 逻辑：原始位置 + (方向 * 爆发力)
            // 加上一点正弦波扰动，让炸开的效果像烟花一样有波动
            const noise = Math.sin(time + i) * 0.2 * smoothedOpenness;
            
            const tx = ox + (ox * explosionFactor) + noise;
            const ty = oy + (oy * explosionFactor * 0.8) + noise; // 高度扩散稍微收敛
            const tz = oz + (oz * explosionFactor) + noise;

            // 插值更新位置
            positions[i3] += (tx - positions[i3]) * 0.15;
            positions[i3+1] += (ty - positions[i3+1]) * 0.15;
            positions[i3+2] += (tz - positions[i3+2]) * 0.15;
        }
        
        particleSystem.geometry.attributes.position.needsUpdate = true;

        // 更新飘雪
        const snowP = snowSystem.geometry.attributes.position.array;
        for(let i=1; i<snowCount*3; i+=3) {
            snowP[i] -= 0.02; 
            if(snowP[i] < -12) snowP[i] = 12; 
        }
        snowSystem.geometry.attributes.position.needsUpdate = true;

        // 标题透明度控制 (炸开时标题淡出，看粒子)
        const titleEl = document.getElementById('title-overlay');
        titleEl.style.opacity = 1 - smoothedOpenness;
        // 如果手张开了，稍微放大标题增加冲击力
        if(smoothedOpenness > 0.1) {
            titleEl.style.transform = `scale(${1 + smoothedOpenness * 0.5})`;
        } else {
             titleEl.style.transform = `scale(1)`;
        }

        renderer.render(scene, camera);
    }
    animate();

    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });
</script>
</body>
</html>
