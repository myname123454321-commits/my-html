<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Stan - 控雨时刻</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@700&display=swap" rel="stylesheet">

    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Segoe UI', sans-serif; }
        
        /* 标题与歌词风格 */
        #title-overlay {
            position: absolute; width: 100%; top: 15%; text-align: center; pointer-events: none; z-index: 5;
            transition: opacity 0.5s;
        }
        h1 {
            font-family: 'Cinzel', serif; 
            color: #e0e0e0; 
            font-size: 4rem; 
            margin: 0;
            letter-spacing: 10px;
            text-transform: uppercase;
            text-shadow: 0 0 20px rgba(255, 255, 255, 0.5);
            opacity: 0.9;
        }
        p.subtitle {
            color: #888; font-size: 1.2rem; letter-spacing: 5px; margin-top: 10px; text-transform: uppercase;
        }

        /* 摄像头小窗 */
        #camera-container {
            position: absolute; top: 20px; left: 20px; width: 240px; height: 180px; z-index: 20;
            border-radius: 4px; overflow: hidden; border: 1px solid rgba(100, 100, 100, 0.5);
            box-shadow: 0 0 30px rgba(0, 0, 0, 0.8); transform: scaleX(-1);
            background: #000;
        }
        .input_video { position: absolute; width: 100%; height: 100%; object-fit: cover; opacity: 0.5; filter: grayscale(100%); } /* 黑白滤镜增加电影感 */
        .output_canvas { position: absolute; width: 100%; height: 100%; }

        /* 启动遮罩层 (用于解决浏览器自动播放限制) */
        #start-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.9); z-index: 100;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            cursor: pointer;
        }
        #start-screen h2 { color: white; font-family: 'Cinzel'; font-size: 2rem; margin-bottom: 20px; }
        #start-screen p { color: #888; }

        #guide-panel {
            position: absolute; bottom: 40px; width: 100%; text-align: center; color: rgba(255,255,255,0.4); z-index: 10;
            pointer-events: none; font-size: 0.9rem; letter-spacing: 2px;
        }
        .key { color: #fff; border-bottom: 1px solid #555; padding-bottom: 2px; }

        #canvas-container { width: 100%; height: 100%; position: absolute; top: 0; left: 0; }
        #loading { display:none; } 
    </style>
</head>
<body>
    <div id="start-screen">
        <h2>CLICK TO START</h2>
        <p>点击屏幕进入雨夜</p>
    </div>

    <audio id="bgm" loop>
        <source src="https://actions.google.com/sounds/v1/weather/rain_heavy_loud.ogg" type="audio/ogg">
    </audio>

    <div id="title-overlay">
        <h1>STAN</h1>
        <p class="subtitle">Rain Control</p>
    </div>

    <div id="camera-container">
        <video class="input_video"></video>
        <canvas class="output_canvas"></canvas>
    </div>

    <div id="guide-panel">
        <span class="key">✊ 握拳</span> 降雨 (Play) &nbsp;&nbsp;&nbsp;&nbsp; 
        <span class="key">✋ 张开</span> 凝固 (Pause)
    </div>

    <div id="canvas-container"></div>

<script>
    // ================= 1. 核心配置 =================
    const RAIN_COUNT = 15000; // 雨滴数量，越多越真实
    const RAIN_SPEED_BASE = 1.2; // 基础下落速度
    
    // ================= 2. 场景初始化 =================
    const scene = new THREE.Scene();
    // 增加黑色雾气，模拟深夜视线受阻的感觉
    scene.fog = new THREE.FogExp2(0x000000, 0.015); 
    
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 0, 20); // 视角平视
    camera.lookAt(0, 0, 0);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    document.getElementById('canvas-container').appendChild(renderer.domElement);

    // ================= 3. 真实感雨滴系统 =================
    // 技巧：使用 Canvas 动态生成一个“长条形”的渐变纹理，而不是简单的圆点
    function createRainTexture() {
        const canvas = document.createElement('canvas');
        canvas.width = 32;
        canvas.height = 256; // 高度很大，模拟雨丝
        const ctx = canvas.getContext('2d');

        // 渐变：头部透明 -> 尾部白色 (模拟雨滴划过的痕迹)
        const gradient = ctx.createLinearGradient(0, 0, 0, 256);
        gradient.addColorStop(0, 'rgba(255, 255, 255, 0)');
        gradient.addColorStop(0.5, 'rgba(150, 180, 255, 0.2)'); // 淡淡的蓝
        gradient.addColorStop(1, 'rgba(255, 255, 255, 0.8)'); // 亮白尾部

        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, 32, 256);

        const texture = new THREE.Texture(canvas);
        texture.needsUpdate = true;
        return texture;
    }

    const rainGeometry = new THREE.BufferGeometry();
    const rainPositions = new Float32Array(RAIN_COUNT * 3);
    const rainVelocities = new Float32Array(RAIN_COUNT); // 独立速度
    
    for (let i = 0; i < RAIN_COUNT; i++) {
        const i3 = i * 3;
        // 宽广的分布范围
        rainPositions[i3] = (Math.random() - 0.5) * 200;
        rainPositions[i3+1] = (Math.random() - 0.5) * 100;
        rainPositions[i3+2] = (Math.random() - 0.5) * 100;
        
        // 随机速度：有的快有的慢，增加层次感
        rainVelocities[i] = 0.8 + Math.random() * 0.4;
    }
    
    rainGeometry.setAttribute('position', new THREE.BufferAttribute(rainPositions, 3));

    const rainMaterial = new THREE.PointsMaterial({
        color: 0xaaaaaa, // 灰白色雨滴
        size: 0.8,       // 粒子基础大小
        map: createRainTexture(), // 使用长条纹理
        transparent: true,
        opacity: 0.7,
        blending: THREE.AdditiveBlending,
        depthWrite: false,
        sizeAttenuation: true // 远处的雨滴变小
    });

    const rainSystem = new THREE.Points(rainGeometry, rainMaterial);
    scene.add(rainSystem);

    // 灯光：模拟街灯或闪电的微光
    const ambientLight = new THREE.AmbientLight(0x222222);
    scene.add(ambientLight);
    const dirLight = new THREE.DirectionalLight(0xaaccff, 0.5);
    dirLight.position.set(0, 50, 0);
    scene.add(dirLight);

    // ================= 4. 音频与交互控制 =================
    const bgm = document.getElementById('bgm');
    let isExperienceStarted = false;

    // 点击启动页开始
    document.getElementById('start-screen').addEventListener('click', () => {
        document.getElementById('start-screen').style.opacity = '0';
        setTimeout(() => document.getElementById('start-screen').style.display = 'none', 500);
        
        isExperienceStarted = true;
        bgm.play().catch(e => console.log("Audio play failed:", e));
        
        // 启动摄像头
        cameraUtils.start();
    });

    // ================= 5. 手势识别 =================
    let handState = 'fist'; // 'fist' | 'open'
    
    const videoElement = document.getElementsByClassName('input_video')[0];
    const canvasElement = document.getElementsByClassName('output_canvas')[0];
    const canvasCtx = canvasElement.getContext('2d');

    function onResults(results) {
        canvasElement.width = videoElement.videoWidth;
        canvasElement.height = videoElement.videoHeight;
        canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);

        if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
            const landmarks = results.multiHandLandmarks[0];
            
            // 极简骨骼绘制 (黑白风)
            drawConnectors(canvasCtx, landmarks, HAND_CONNECTIONS, {color: 'rgba(255,255,255,0.3)', lineWidth: 1});
            drawLandmarks(canvasCtx, landmarks, {color: 'rgba(255,255,255,0.8)', lineWidth: 1, radius: 2});

            // 握拳检测
            const wrist = landmarks[0];
            const tips = [8, 12, 16, 20];
            let dist = 0;
            tips.forEach(i => dist += Math.hypot(landmarks[i].x - wrist.x, landmarks[i].y - wrist.y));
            // 距离阈值判断
            handState = (dist / 4) > 0.35 ? 'open' : 'fist';

        } else {
            handState = 'fist'; // 默认下雨
        }
    }

    const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
    hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });
    hands.onResults(onResults);

    const cameraUtils = new Camera(videoElement, {
        onFrame: async () => { await hands.send({image: videoElement}); },
        width: 320, height: 240
    });
    // cameraUtils.start() 移到了点击事件里

    // ================= 6. 动画主循环 =================
    let currentSpeed = RAIN_SPEED_BASE;
    let time = 0;

    function animate() {
        requestAnimationFrame(animate);
        time += 0.01;

        if (!isExperienceStarted) {
            renderer.render(scene, camera);
            return;
        }

        // --- 音乐与速度控制逻辑 ---
        let targetSpeed = RAIN_SPEED_BASE;

        if (handState === 'open') {
            // 张手：停雨 & 停音乐
            targetSpeed = 0;
            if (!bgm.paused) bgm.pause();
        } else {
            // 握拳：下雨 & 放音乐
            targetSpeed = RAIN_SPEED_BASE;
            if (bgm.paused) bgm.play();
        }

        // 速度平滑过渡 (Lerp)
        currentSpeed += (targetSpeed - currentSpeed) * 0.1;

        // --- 粒子物理更新 ---
        const positions = rainSystem.geometry.attributes.position.array;

        for (let i = 0; i < RAIN_COUNT; i++) {
            const i3 = i * 3;
            
            // 下落公式：Y -= 速度 * 个体差异
            positions[i3 + 1] -= currentSpeed * rainVelocities[i];

            // 循环下落：掉出底界，回到顶界
            if (positions[i3 + 1] < -50) {
                positions[i3 + 1] = 50;
            }

            // 悬停时的微动 (Suspension Effect)
            // 当速度接近0时，给雨滴加一点点上下浮动，像魔法控制一样
            if (currentSpeed < 0.1) {
                positions[i3 + 1] += Math.sin(time * 2 + i) * 0.005; 
            }
        }
        
        rainSystem.geometry.attributes.position.needsUpdate = true;

        // 相机微动 (Handheld Camera Feel)
        camera.position.y += Math.sin(time * 0.5) * 0.005;
        camera.rotation.z = Math.sin(time * 0.2) * 0.002;

        renderer.render(scene, camera);
    }
    animate();

    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });
</script>
</body>
</html>
