<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æƒŠå¤©é­”ç›—å›¢ - æ§é›¨ç‰¹æ•ˆ</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@700&display=swap" rel="stylesheet">

    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Segoe UI', sans-serif; }
        
        #title-overlay {
            position: absolute; width: 100%; top: 10%; text-align: center; pointer-events: none; z-index: 5;
        }
        h1 {
            font-family: 'Cinzel', serif; 
            color: #aaddff; 
            font-size: 5rem; 
            margin: 0;
            letter-spacing: 15px;
            text-transform: uppercase;
            text-shadow: 0 0 20px #0055ff, 0 0 40px #aaddff;
            opacity: 0.8;
        }

        #camera-container {
            position: absolute; top: 20px; left: 20px; width: 240px; height: 180px; z-index: 20;
            border-radius: 12px; overflow: hidden; border: 2px solid rgba(100, 200, 255, 0.5);
            box-shadow: 0 0 20px rgba(0, 100, 255, 0.3); transform: scaleX(-1);
            background: #000;
        }
        .input_video { position: absolute; width: 100%; height: 100%; object-fit: cover; opacity: 0.6; }
        .output_canvas { position: absolute; width: 100%; height: 100%; }

        #guide-panel {
            position: absolute; bottom: 40px; width: 100%; text-align: center; color: rgba(170, 221, 255, 0.7); z-index: 10;
            pointer-events: none; font-size: 1.1rem; letter-spacing: 2px; text-transform: uppercase;
        }
        .key { color: #fff; font-weight: bold; border-bottom: 2px solid #0055ff; margin: 0 5px; }

        #canvas-container { width: 100%; height: 100%; position: absolute; top: 0; left: 0; }
        #loading { position: absolute; top: 50%; left: 50%; transform: translate(-50%,-50%); color: #aaddff; font-size: 1.5rem; z-index: 100; text-align: center; }
    </style>
</head>
<body>
    <div id="loading">âš¡ æ­£åœ¨å¬å”¤é£æš´...<br>è¯·å…è®¸æ‘„åƒå¤´æƒé™</div>

    <div id="title-overlay">
        <h1>Rain Control</h1>
    </div>

    <div id="camera-container">
        <video class="input_video"></video>
        <canvas class="output_canvas"></canvas>
    </div>

    <div id="guide-panel">
        <span class="key">âœŠ æ¡æ‹³</span> é™é›¨ &nbsp;&nbsp;/&nbsp;&nbsp; 
        <span class="key">âœ‹ å¼ å¼€</span> å‡å›º &nbsp;&nbsp;/&nbsp;&nbsp; 
        <span class="key">â˜ï¸ ä¸ŠæŠ¬</span> é€†æµ
    </div>

    <div id="canvas-container"></div>

<script>
    // ================= é…ç½®åŒºåŸŸ =================
    const RAIN_COUNT = 15000; // é›¨æ»´æ•°é‡
    const RAIN_SPEED_BASE = 0.8; // åŸºç¡€ä¸‹è½é€Ÿåº¦
    
    // ================= åœºæ™¯åˆå§‹åŒ– =================
    const scene = new THREE.Scene();
    // ç”µå½±çº§å†·è‰²è°ƒé›¾æ°”
    scene.fog = new THREE.FogExp2(0x051020, 0.02); 
    
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 5, 10);
    camera.lookAt(0, 0, 0);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    document.getElementById('canvas-container').appendChild(renderer.domElement);

    // ================= ğŸŒ§ï¸ é›¨æ»´ç²’å­ç³»ç»Ÿ =================
    const rainGeo = new THREE.BufferGeometry();
    const rainPos = new Float32Array(RAIN_COUNT * 3);
    const rainVel = new Float32Array(RAIN_COUNT); // æ¯ä¸ªé›¨æ»´çš„ç‹¬ç«‹é€Ÿåº¦
    
    for (let i = 0; i < RAIN_COUNT; i++) {
        const i3 = i * 3;
        // éšæœºåˆ†å¸ƒåœ¨å·¨å¤§çš„ç©ºé—´é‡Œ
        rainPos[i3] = (Math.random() - 0.5) * 60;     // X
        rainPos[i3+1] = (Math.random() - 0.5) * 40;   // Y (é«˜åº¦)
        rainPos[i3+2] = (Math.random() - 0.5) * 40;   // Z
        
        // éšæœºé€Ÿåº¦ï¼Œåˆ¶é€ å±‚æ¬¡æ„Ÿ
        rainVel[i] = 0.5 + Math.random() * 0.5;
    }
    
    rainGeo.setAttribute('position', new THREE.BufferAttribute(rainPos, 3));

    // ç”Ÿæˆé›¨æ»´è´´å›¾ (æ‹‰é•¿çš„æ°´æ»´çŠ¶)
    function getRainTexture() {
        const canvas = document.createElement('canvas');
        canvas.width = 32; canvas.height = 64;
        const ctx = canvas.getContext('2d');
        
        // ç”»ä¸€ä¸ªæ‹‰é•¿çš„æ¤­åœ†æ¸å˜
        const grad = ctx.createLinearGradient(0, 0, 0, 64);
        grad.addColorStop(0, 'rgba(200, 230, 255, 0)');   // å°¾éƒ¨é€æ˜
        grad.addColorStop(1, 'rgba(255, 255, 255, 0.8)'); // å¤´éƒ¨äº®ç™½
        
        ctx.fillStyle = grad;
        ctx.fillRect(14, 0, 4, 64); // ç»†é•¿çš„çº¿
        
        const texture = new THREE.Texture(canvas);
        texture.needsUpdate = true;
        return texture;
    }

    const rainMat = new THREE.PointsMaterial({
        color: 0xaaddff,
        size: 0.4,
        map: getRainTexture(),
        transparent: true,
        opacity: 0.8,
        blending: THREE.AdditiveBlending,
        depthWrite: false,
        sizeAttenuation: true
    });

    const rainSystem = new THREE.Points(rainGeo, rainMat);
    scene.add(rainSystem);

    // æ·»åŠ ç¯å¢ƒå…‰ï¼Œè®©åœºæ™¯ä¸é‚£ä¹ˆæ­»é»‘
    const ambientLight = new THREE.AmbientLight(0x404040, 2); 
    scene.add(ambientLight);
    
    // åŠ ä¸€ä¸ªèšå…‰ç¯æ¨¡æ‹Ÿè¡—ç¯æ•ˆæœ
    const spotLight = new THREE.SpotLight(0x0055ff, 5);
    spotLight.position.set(0, 20, 0);
    spotLight.angle = Math.PI / 4;
    spotLight.penumbra = 0.5;
    scene.add(spotLight);

    // ================= æ‰‹åŠ¿è¯†åˆ« =================
    let handState = 'fist'; // 'fist' | 'open'
    let handY = 0.5; // æ‰‹çš„é«˜åº¦ (0-1)
    let prevHandY = 0.5;
    let liftSpeed = 0; // æ‰‹å‘ä¸ŠæŠ¬çš„é€Ÿåº¦
    
    const videoElement = document.getElementsByClassName('input_video')[0];
    const canvasElement = document.getElementsByClassName('output_canvas')[0];
    const canvasCtx = canvasElement.getContext('2d');

    function onResults(results) {
        document.getElementById('loading').style.display = 'none';
        canvasElement.width = videoElement.videoWidth;
        canvasElement.height = videoElement.videoHeight;
        canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);

        if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
            const landmarks = results.multiHandLandmarks[0];
            
            // ç»˜åˆ¶éª¨éª¼ (ç§‘æŠ€è“é£æ ¼)
            drawConnectors(canvasCtx, landmarks, HAND_CONNECTIONS, {color: '#00ccff', lineWidth: 2});
            drawLandmarks(canvasCtx, landmarks, {color: '#ffffff', lineWidth: 1, radius: 2});

            // 1. åˆ¤æ–­å¼€åˆ (Open/Fist)
            const wrist = landmarks[0];
            const tips = [8, 12, 16, 20];
            let dist = 0;
            tips.forEach(i => dist += Math.hypot(landmarks[i].x - wrist.x, landmarks[i].y - wrist.y));
            // è·ç¦»å¤§=å¼ å¼€ï¼Œè·ç¦»å°=æ¡æ‹³
            const openness = dist / 4; 
            handState = openness > 0.35 ? 'open' : 'fist';

            // 2. è®¡ç®—æ‰‹åŠ¿ç§»åŠ¨ (ç”¨äºæ§åˆ¶é›¨æ»´é€†æµ)
            handY = landmarks[9].y; // ä¸­æŒ‡æ ¹éƒ¨é«˜åº¦
            // è®¡ç®—å‚ç›´ç§»åŠ¨é€Ÿåº¦ (å½“å‰Y - ä¸Šä¸€å¸§Y)
            // æ³¨æ„ï¼šMediaPipeé‡Œ y=0æ˜¯é¡¶éƒ¨ï¼Œy=1æ˜¯åº•éƒ¨ã€‚æ‰€ä»¥å˜å°æ˜¯å‘ä¸Šã€‚
            liftSpeed = (prevHandY - handY) * 50; // æ”¾å¤§ç³»æ•°
            prevHandY = handY;

        } else {
            handState = 'fist'; // æ²¡æ‰‹é»˜è®¤ä¸‹é›¨
            liftSpeed = 0;
        }
    }

    const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
    hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });
    hands.onResults(onResults);

    const cameraUtils = new Camera(videoElement, {
        onFrame: async () => { await hands.send({image: videoElement}); },
        width: 320, height: 240
    });
    cameraUtils.start();

    // ================= ç‰©ç†åŠ¨ç”»å¾ªç¯ =================
    let currentRainSpeed = RAIN_SPEED_BASE;
    let time = 0;

    function animate() {
        requestAnimationFrame(animate);
        time += 0.01;

        // --- æ ¸å¿ƒæ§åˆ¶é€»è¾‘ ---
        let targetSpeed = RAIN_SPEED_BASE;

        if (handState === 'open') {
            // å¼ å¼€æ‰‹ï¼šç›®æ ‡é€Ÿåº¦ä¸º 0 (é™æ­¢)
            targetSpeed = 0;
            
            // è¿›é˜¶ï¼šå¦‚æœæ‰‹å‘ä¸ŠæŠ¬å¾—å¾ˆå¿« (liftSpeed > 0.5)ï¼Œé›¨æ»´å€’æµ
            if (liftSpeed > 0.8) {
                targetSpeed = -1.5; // è´Ÿæ•°ä»£è¡¨å‘ä¸Šé£
            }
        } else {
            // æ¡æ‹³ï¼šæ­£å¸¸ä¸‹é›¨
            targetSpeed = RAIN_SPEED_BASE;
        }

        // å¹³æ»‘è¿‡æ¸¡é€Ÿåº¦ (Lerp)ï¼Œè®©æ€¥åœæ€¥èµ·æ›´æœ‰è´¨æ„Ÿ
        currentRainSpeed += (targetSpeed - currentRainSpeed) * 0.1;

        // --- æ›´æ–°ç²’å­ä½ç½® ---
        const positions = rainSystem.geometry.attributes.position.array;

        for (let i = 0; i < RAIN_COUNT; i++) {
            const i3 = i * 3;
            
            // ç‰©ç†å…¬å¼ï¼šY = Y - é€Ÿåº¦ * ä¸ªä½“å·®å¼‚
            // å¦‚æœ currentRainSpeed æ˜¯ 0ï¼Œå®ƒå°±åœä½äº†
            // å¦‚æœæ˜¯è´Ÿæ•°ï¼Œå®ƒå°±åŠ ä¸Šå»ï¼ˆå€’æµï¼‰
            positions[i3+1] -= currentRainSpeed * rainVel[i];

            // è¾¹ç•Œå¾ªç¯å¤„ç† (æ— é™é›¨æ»´)
            // æ­£å¸¸ä¸‹é›¨æ—¶ï¼šæ‰åˆ°åº•éƒ¨ -> å›åˆ°é¡¶éƒ¨
            if (positions[i3+1] < -20) {
                positions[i3+1] = 20;
            }
            // å€’æµæ—¶ï¼šé£åˆ°é¡¶éƒ¨ -> å›åˆ°åº•éƒ¨
            if (positions[i3+1] > 20) {
                positions[i3+1] = -20;
            }
            
            // æ‚¬åœæŠ–åŠ¨æ•ˆæœï¼šå½“é€Ÿåº¦æ¥è¿‘0æ—¶ï¼ŒåŠ ä¸€ç‚¹ç‚¹å¾®é¢¤ï¼Œåƒè¢«å¿µåŠ›æ§åˆ¶ä¸€æ ·
            if (Math.abs(currentRainSpeed) < 0.1) {
                positions[i3] += Math.sin(time + i) * 0.002; // Xè½´å¾®é¢¤
                positions[i3+1] += Math.cos(time + i) * 0.002; // Yè½´å¾®é¢¤
            }
        }
        
        rainSystem.geometry.attributes.position.needsUpdate = true;

        // æ‘„åƒæœºå¾®åŠ¨ï¼Œå¢åŠ ç”µå½±æ„Ÿ
        camera.position.x = Math.sin(time * 0.2) * 0.5;
        camera.lookAt(0, 0, 0);

        renderer.render(scene, camera);
    }
    animate();

    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });
</script>
</body>
</html>
