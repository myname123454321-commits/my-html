<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Stan - 控雨时刻</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@700&display=swap" rel="stylesheet">

    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Segoe UI', sans-serif; }
        
        /* 标题 */
        #title-overlay {
            position: absolute; width: 100%; top: 15%; text-align: center; pointer-events: none; z-index: 5;
            transition: opacity 0.5s;
        }
        h1 {
            font-family: 'Cinzel', serif; 
            color: #e0e0e0; 
            font-size: 4rem; 
            margin: 0;
            letter-spacing: 10px;
            text-transform: uppercase;
            text-shadow: 0 0 20px rgba(255, 255, 255, 0.5);
            opacity: 0.9;
        }
        p.subtitle {
            color: #888; font-size: 1.2rem; letter-spacing: 5px; margin-top: 10px; text-transform: uppercase;
        }

        /* 摄像头小窗 - 修正版 */
        #camera-container {
            position: absolute; top: 20px; left: 20px; width: 240px; height: 180px; z-index: 20;
            border-radius: 4px; overflow: hidden; border: 1px solid rgba(100, 100, 100, 0.5);
            box-shadow: 0 0 30px rgba(0, 0, 0, 0.8); transform: scaleX(-1);
            background: #000;
        }
        /* 移除 grayscale 滤镜，调高 opacity */
        .input_video { position: absolute; width: 100%; height: 100%; object-fit: cover; opacity: 0.9; } 
        .output_canvas { position: absolute; width: 100%; height: 100%; }

        /* 启动遮罩 */
        #start-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.9); z-index: 100;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            cursor: pointer;
        }
        #start-screen h2 { color: white; font-family: 'Cinzel'; font-size: 2rem; margin-bottom: 20px; }
        #start-screen p { color: #888; }

        #guide-panel {
            position: absolute; bottom: 40px; width: 100%; text-align: center; color: rgba(255,255,255,0.4); z-index: 10;
            pointer-events: none; font-size: 0.9rem; letter-spacing: 2px;
        }
        .key { color: #fff; border-bottom: 1px solid #555; padding-bottom: 2px; }

        #canvas-container { width: 100%; height: 100%; position: absolute; top: 0; left: 0; }
        #loading { display:none; } 
    </style>
</head>
<body>
    <div id="start-screen">
        <h2>CLICK TO START</h2>
        <p>点击屏幕进入雨夜</p>
    </div>

    <audio id="bgm" loop>
        <source src="./M800004WDS6p3EeOIq.mp3" type="audio/mp3">
    </audio>

    <div id="title-overlay">
        <h1>STAN</h1>
        <p class="subtitle">Rain Control</p>
    </div>

    <div id="camera-container">
        <video class="input_video"></video>
        <canvas class="output_canvas"></canvas>
    </div>

    <div id="guide-panel">
        <span class="key">✊ 握拳</span> 降雨 (Play) &nbsp;&nbsp;&nbsp;&nbsp; 
        <span class="key">✋ 张开</span> 凝固 (Pause)
    </div>

    <div id="canvas-container"></div>

<script>
    // ================= 1. 核心配置 =================
    const RAIN_COUNT = 15000; 
    const RAIN_SPEED_BASE = 1.2; 
    
    // ================= 2. 场景初始化 =================
    const scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x000000, 0.015); 
    
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 0, 20); 
    camera.lookAt(0, 0, 0);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    document.getElementById('canvas-container').appendChild(renderer.domElement);

    // ================= 3. 真实感雨滴系统 (修正版) =================
    function createRainTexture() {
        const canvas = document.createElement('canvas');
        canvas.width = 32;
        canvas.height = 256; 
        const ctx = canvas.getContext('2d');

        const gradient = ctx.createLinearGradient(0, 0, 0, 256);
        gradient.addColorStop(0, 'rgba(255, 255, 255, 0)');
        gradient.addColorStop(0.5, 'rgba(180, 200, 255, 0.1)'); // 调淡颜色
        gradient.addColorStop(1, 'rgba(255, 255, 255, 0.6)'); 

        ctx.fillStyle = gradient;
        // 把线条画得更细一点，之前的 32px 宽太粗了
        ctx.fillRect(15, 0, 2, 256); 

        const texture = new THREE.Texture(canvas);
        texture.needsUpdate = true;
        return texture;
    }

    const rainGeometry = new THREE.BufferGeometry();
    const rainPositions = new Float32Array(RAIN_COUNT * 3);
    const rainVelocities = new Float32Array(RAIN_COUNT); 
    
    for (let i = 0; i < RAIN_COUNT; i++) {
        const i3 = i * 3;
        rainPositions[i3] = (Math.random() - 0.5) * 200;
        rainPositions[i3+1] = (Math.random() - 0.5) * 100;
        rainPositions[i3+2] = (Math.random() - 0.5) * 100;
        
        rainVelocities[i] = 0.8 + Math.random() * 0.4;
    }
    
    rainGeometry.setAttribute('position', new THREE.BufferAttribute(rainPositions, 3));

    const rainMaterial = new THREE.PointsMaterial({
        color: 0xaaaaaa, 
        size: 0.3,       // [修改] 尺寸缩小到 0.3 (之前是 0.8)
        map: createRainTexture(), 
        transparent: true,
        opacity: 0.7,
        blending: THREE.AdditiveBlending,
        depthWrite: false,
        sizeAttenuation: true 
    });

    const rainSystem = new THREE.Points(rainGeometry, rainMaterial);
    scene.add(rainSystem);

    const ambientLight = new THREE.AmbientLight(0x222222);
    scene.add(ambientLight);
    const dirLight = new THREE.DirectionalLight(0xaaccff, 0.5);
    dirLight.position.set(0, 50, 0);
    scene.add(dirLight);

    // ================= 4. 音频与交互 =================
    const bgm = document.getElementById('bgm');
    let isExperienceStarted = false;

    document.getElementById('start-screen').addEventListener('click', () => {
        document.getElementById('start-screen').style.opacity = '0';
        setTimeout(() => document.getElementById('start-screen').style.display = 'none', 500);
        
        isExperienceStarted = true;
        // 尝试播放音乐
        bgm.play().then(() => {
            console.log("Music started");
        }).catch(e => {
            console.error("Music play failed:", e);
            alert("音乐播放失败，请检查文件名是否正确");
        });
        
        cameraUtils.start();
    });

    // ================= 5. 手势识别 =================
    let handState = 'fist'; 
    
    const videoElement = document.getElementsByClassName('input_video')[0];
    const canvasElement = document.getElementsByClassName('output_canvas')[0];
    const canvasCtx = canvasElement.getContext('2d');

    function onResults(results) {
        canvasElement.width = videoElement.videoWidth;
        canvasElement.height = videoElement.videoHeight;
        canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);

        if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
            const landmarks = results.multiHandLandmarks[0];
            
            // 骨骼颜色
            drawConnectors(canvasCtx, landmarks, HAND_CONNECTIONS, {color: 'rgba(0, 200, 255, 0.5)', lineWidth: 1});
            drawLandmarks(canvasCtx, landmarks, {color: 'rgba(255,255,255,0.8)', lineWidth: 1, radius: 2});

            const wrist = landmarks[0];
            const tips = [8, 12, 16, 20];
            let dist = 0;
            tips.forEach(i => dist += Math.hypot(landmarks[i].x - wrist.x, landmarks[i].y - wrist.y));
            handState = (dist / 4) > 0.35 ? 'open' : 'fist';

        } else {
            handState = 'fist'; 
        }
    }

    const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
    hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });
    hands.onResults(onResults);

    const cameraUtils = new Camera(videoElement, {
        onFrame: async () => { await hands.send({image: videoElement}); },
        width: 320, height: 240
    });

    // ================= 6. 动画主循环 =================
    let currentSpeed = RAIN_SPEED_BASE;
    let time = 0;

    function animate() {
        requestAnimationFrame(animate);
        time += 0.01;

        if (!isExperienceStarted) {
            renderer.render(scene, camera);
            return;
        }

        let targetSpeed = RAIN_SPEED_BASE;

        if (handState === 'open') {
            targetSpeed = 0; // 停雨
            if (!bgm.paused) bgm.pause();
        } else {
            targetSpeed = RAIN_SPEED_BASE; // 下雨
            if (bgm.paused) bgm.play();
        }

        currentSpeed += (targetSpeed - currentSpeed) * 0.1;

        const positions = rainSystem.geometry.attributes.position.array;

        for (let i = 0; i < RAIN_COUNT; i++) {
            const i3 = i * 3;
            
            positions[i3 + 1] -= currentSpeed * rainVelocities[i];

            if (positions[i3 + 1] < -50) {
                positions[i3 + 1] = 50;
            }

            // 悬停微颤
            if (currentSpeed < 0.1) {
                positions[i3 + 1] += Math.sin(time * 2 + i) * 0.005; 
            }
        }
        
        rainSystem.geometry.attributes.position.needsUpdate = true;

        // 相机微动
        camera.position.y += Math.sin(time * 0.5) * 0.005;
        camera.rotation.z = Math.sin(time * 0.2) * 0.002;

        renderer.render(scene, camera);
    }
    animate();

    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });
</script>
</body>
</html>
