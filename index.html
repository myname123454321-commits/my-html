<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D æ‰‹åŠ¿äº¤äº’ç²’å­ç³»ç»Ÿ</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            font-family: 'Segoe UI', Roboto, sans-serif;
        }

        #canvas-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        /* ç”¨äº MediaPipe çš„éšè—è§†é¢‘å…ƒç´  */
        .input_video {
            display: none; 
        }

        /* UI é¢æ¿æ ·å¼ */
        #ui-panel {
            position: absolute;
            top: 20px;
            right: 20px;
            z-index: 10;
            background: rgba(255, 255, 255, 0.15);
            backdrop-filter: blur(10px); /* æ¯›ç»ç’ƒæ•ˆæœ */
            padding: 20px;
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: white;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
            width: 220px;
        }

        .ui-group { margin-bottom: 15px; }
        .ui-label { display: block; margin-bottom: 8px; font-weight: 500; font-size: 14px;}

        /* æŒ‰é’®æ ·å¼ */
        .shape-btn {
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: white;
            padding: 8px 12px;
            margin: 4px;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s;
            font-size: 13px;
        }
        .shape-btn:hover { background: rgba(255, 255, 255, 0.2); }
        .shape-btn.active { background: #2563eb; border-color: #2563eb; }

        /* é¢œè‰²é€‰æ‹©å™¨å’Œå…¨å±æŒ‰é’® */
        input[type="color"] {
            width: 100%; height: 35px; border: none; border-radius: 6px; cursor: pointer;
        }
        #fullscreen-btn {
            width: 100%; padding: 10px; background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.3); color: white; border-radius: 6px;
            cursor: pointer; margin-top: 10px;
        }
        #fullscreen-btn:hover { background: rgba(255, 255, 255, 0.2); }

        /* åŠ è½½æç¤º */
        #loading {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: white; z-index: 20; font-size: 1.2rem; pointer-events: none;
        }
    </style>
</head>
<body>
    <div id="loading">æ­£åœ¨å¯åŠ¨æ‘„åƒå¤´å’Œ AI æ¨¡å‹ï¼Œè¯·ç¨å€™...<br>(è¯·å…è®¸æ‘„åƒå¤´æƒé™)</div>
    <video class="input_video"></video>
    
    <div id="canvas-container"></div>

    <div id="ui-panel">
        <div class="ui-group">
            <label class="ui-label">é€‰æ‹©æ¨¡å‹å½¢çŠ¶</label>
            <button class="shape-btn active" data-shape="heart">çˆ±å¿ƒ â¤ï¸</button>
            <button class="shape-btn" data-shape="sphere">åœŸæ˜Ÿ(çƒä½“) ğŸª</button>
            <button class="shape-btn" data-shape="cube">æ–¹å— ğŸ§Š</button>
        </div>
        <div class="ui-group">
            <label class="ui-label">ç²’å­é¢œè‰²</label>
            <input type="color" id="color-picker" value="#ff4444">
        </div>
        <button id="fullscreen-btn">ğŸ“º åˆ‡æ¢å…¨å±</button>
        <p style="font-size: 12px; opacity: 0.7; margin-top: 15px;">æç¤ºï¼šä¼¸å‡ºæ‰‹æŒå¯¹å‡†æ‘„åƒå¤´ã€‚<br>æ¡æ‹³=èšåˆï¼Œå¼ å¼€=æ‰©æ•£ã€‚</p>
    </div>


<script>
    // ================= é…ç½®åŒºåŸŸ =================
    const PARTICLE_COUNT = 5000; // ç²’å­æ•°é‡ï¼Œè¿‡å¤šä¼šå¡é¡¿
    const PARTICLE_SIZE = 0.05;  // ç²’å­å¤§å°
    let currentColor = 0xff4444; // åˆå§‹é¢œè‰²
    let currentShape = 'heart';  // åˆå§‹å½¢çŠ¶

    // ================= Three.js åŸºç¡€è®¾ç½® =================
    const scene = new THREE.Scene();
    // æ·»åŠ ä¸€ç‚¹è¿·é›¾æ•ˆæœ
    scene.fog = new THREE.FogExp2(0x000000, 0.02);
    
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.z = 5;

    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    document.getElementById('canvas-container').appendChild(renderer.domElement);

    // ================= ç²’å­ç³»ç»Ÿæ ¸å¿ƒ =================
    // å­˜å‚¨ä¸åŒå½¢çŠ¶çš„ç›®æ ‡ä½ç½®æ•°æ®
    const shapes = {
        heart: new Float32Array(PARTICLE_COUNT * 3),
        sphere: new Float32Array(PARTICLE_COUNT * 3),
        cube: new Float32Array(PARTICLE_COUNT * 3)
    };

    // é¢„è®¡ç®—å½¢çŠ¶æ•°æ®çš„å‡½æ•°
    function precomputeShapes() {
        const v3 = new THREE.Vector3();
        for (let i = 0; i < PARTICLE_COUNT; i++) {
            const i3 = i * 3;

            // 1. çˆ±å¿ƒå½¢çŠ¶ (æ•°å­¦å‚æ•°æ–¹ç¨‹)
            const t = Math.random() * Math.PI * 2;
            // è¿™æ˜¯ä¸€ä¸ªæ›´é¥±æ»¡çš„çˆ±å¿ƒæ–¹ç¨‹
            let x = 16 * Math.pow(Math.sin(t), 3);
            let y = 13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t);
            let z = (Math.random() - 0.5) * 4; // å¢åŠ ä¸€ç‚¹åšåº¦
            v3.set(x, y, z).multiplyScalar(0.15); // ç¼©æ”¾
            shapes.heart[i3] = v3.x; shapes.heart[i3+1] = v3.y; shapes.heart[i3+2] = v3.z;

            // 2. çƒä½“ (åœŸæ˜Ÿä¸»ä½“)
            const phi = Math.acos(-1 + (2 * i) / PARTICLE_COUNT);
            const theta = Math.sqrt(PARTICLE_COUNT * Math.PI) * phi;
            v3.setFromSphericalCoords(2.5, phi, theta); // åŠå¾„2.5
            shapes.sphere[i3] = v3.x; shapes.sphere[i3+1] = v3.y; shapes.sphere[i3+2] = v3.z;

            // 3. æ–¹å— (éšæœºåˆ†å¸ƒåœ¨ç«‹æ–¹ä½“å†…)
            const boxSize = 4;
            v3.set(
                (Math.random() - 0.5) * boxSize,
                (Math.random() - 0.5) * boxSize,
                (Math.random() - 0.5) * boxSize
            );
            shapes.cube[i3] = v3.x; shapes.cube[i3+1] = v3.y; shapes.cube[i3+2] = v3.z;
        }
    }
    precomputeShapes();

    // åˆ›å»ºå®é™…æ˜¾ç¤ºçš„ç²’å­å‡ ä½•ä½“
    const geometry = new THREE.BufferGeometry();
    // åˆå§‹ä½ç½®å…ˆå…¨éƒ¨è®¾ä¸º0
    const positions = new Float32Array(PARTICLE_COUNT * 3);
    geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));

    // ç²’å­æè´¨
    const material = new THREE.PointsMaterial({
        color: currentColor,
        size: PARTICLE_SIZE,
        transparent: true,
        opacity: 0.8,
        blending: THREE.AdditiveBlending, // å‘å…‰å åŠ æ¨¡å¼
        depthWrite: false
    });

    const particleSystem = new THREE.Points(geometry, material);
    scene.add(particleSystem);


    // ================= MediaPipe æ‰‹åŠ¿è¯†åˆ« =================
    let handOpenness = 0; // 0 = æ¡æ‹³, 1 = å®Œå…¨å¼ å¼€

    const videoElement = document.getElementsByClassName('input_video')[0];

    function onResults(results) {
        document.getElementById('loading').style.display = 'none';

        if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
            // åªå–ç¬¬ä¸€åªæ‰‹
            const landmarks = results.multiHandLandmarks[0];
            
            // è®¡ç®—ç®€å•çš„æ‰‹æŒå¼€åˆåº¦ï¼šè®¡ç®—æŒ‡å°–(ç´¢å¼• 8,12,16,20)åˆ°æ‰‹è…•(ç´¢å¼• 0)çš„å¹³å‡è·ç¦»
            const wrist = landmarks[0];
            const fingertips = [8, 12, 16, 20];
            let totalDistance = 0;
            
            fingertips.forEach(tipIndex => {
                const tip = landmarks[tipIndex];
                // è®¡ç®—ç®€å•çš„æ¬§å‡ é‡Œå¾—è·ç¦» (è¿™é‡Œåªç”¨xå’Œyåšè¿‘ä¼¼ï¼Œè¶³å¤Ÿäº†)
                const dx = tip.x - wrist.x;
                const dy = tip.y - wrist.y;
                totalDistance += Math.sqrt(dx*dx + dy*dy);
            });
            
            const avgDistance = totalDistance / 4;
            // æ ¹æ®ç»éªŒï¼Œè·ç¦»åœ¨ 0.2 åˆ° 0.6 ä¹‹é—´å˜åŒ–ã€‚å°†å…¶æ˜ å°„åˆ° 0-1 ä¹‹é—´ã€‚
            // å¯ä»¥æ ¹æ®å®é™…ä½“éªŒå¾®è°ƒè¿™é‡Œçš„æ•°å€¼
            handOpenness = Math.max(0, Math.min(1, (avgDistance - 0.15) * 2.5));
        } else {
            // å¦‚æœæ²¡æœ‰æ£€æµ‹åˆ°æ‰‹ï¼Œç¼“æ…¢å›åˆ°å¼ å¼€çŠ¶æ€
             handOpenness = (handOpenness * 0.95) + (1 * 0.05);
        }
    }

    const hands = new Hands({locateFile: (file) => {
        return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
    }});
    hands.setOptions({
        maxNumHands: 1, // åªæ£€æµ‹å•æ‰‹
        modelComplexity: 1,
        minDetectionConfidence: 0.5,
        minTrackingConfidence: 0.5
    });
    hands.onResults(onResults);

    const cameraUtils = new Camera(videoElement, {
        onFrame: async () => {
            await hands.send({image: videoElement});
        },
        width: 640,
        height: 480
    });
    cameraUtils.start();


    // ================= åŠ¨ç”»å¾ªç¯ & äº¤äº’é€»è¾‘ =================
    
    // ç¼“åŠ¨ç³»æ•°ï¼Œè®©åŠ¨ä½œæ›´å¹³æ»‘
    let smoothedOpenness = 1;

    function animate() {
        requestAnimationFrame(animate);

        // å¹³æ»‘æ‰‹åŠ¿æ•°å€¼
        smoothedOpenness += (handOpenness - smoothedOpenness) * 0.1;

        const currentPositions = geometry.attributes.position.array;
        const targetShapeData = shapes[currentShape];

        // æ ¸å¿ƒé€»è¾‘ï¼šæ ¹æ®æ‰‹åŠ¿æ›´æ–°ç²’å­ä½ç½®
        for (let i = 0; i < PARTICLE_COUNT; i++) {
            const i3 = i * 3;
            
            // è·å–å½“å‰ç²’å­çš„ç›®æ ‡å½¢çŠ¶ä½ç½®
            const tx = targetShapeData[i3];
            const ty = targetShapeData[i3 + 1];
            const tz = targetShapeData[i3 + 2];

            // è®¡ç®—æ‰©æ•£æ–¹å‘ (ç®€å•çš„ä»åŸç‚¹å‘å¤–)
            const dist = Math.sqrt(tx*tx + ty*ty + tz*tz) + 0.001; // é˜²æ­¢é™¤ä»¥0
            const dirX = tx / dist;
            const dirY = ty / dist;
            const dirZ = tz / dist;

            // æ‰©æ•£åŠ›åº¦ï¼šæ‰‹å¼ å¾—è¶Šå¤§ï¼Œæ‰©æ•£è¶Šè¿œ
            const explodeFactor = smoothedOpenness * 5.0; // æœ€å¤§æ‰©æ•£5å€è·ç¦»

            // çº¿æ€§æ’å€¼ï¼šåœ¨â€œèšåˆå½¢æ€â€å’Œâ€œæ‰©æ•£å½¢æ€â€ä¹‹é—´è¿‡æ¸¡
            // å½“ smoothedOpenness æ¥è¿‘ 0 (æ¡æ‹³)ï¼Œç²’å­é è¿‘ targetShapeData
            // å½“ smoothedOpenness æ¥è¿‘ 1 (å¼ å¼€)ï¼Œç²’å­å‘å¤–çˆ†ç‚¸
            currentPositions[i3] = tx + dirX * explodeFactor * dist;
            currentPositions[i3 + 1] = ty + dirY * explodeFactor * dist;
            currentPositions[i3 + 2] = tz + dirZ * explodeFactor * dist;
        }
        // å‘Šè¯‰ Three.js ä½ç½®æ•°æ®å·²æ›´æ–°
        geometry.attributes.position.needsUpdate = true;

        // ç¼“æ…¢æ—‹è½¬æ•´ä¸ªç²’å­ç³»ç»Ÿ
        particleSystem.rotation.y += 0.002;
        particleSystem.rotation.x += 0.001;

        renderer.render(scene, camera);
    }
    animate();


    // ================= UI äº‹ä»¶ç›‘å¬ =================

    // 1. å½¢çŠ¶åˆ‡æ¢
    document.querySelectorAll('.shape-btn').forEach(btn => {
        btn.addEventListener('click', (e) => {
            // æ›´æ–°æŒ‰é’®çŠ¶æ€
            document.querySelectorAll('.shape-btn').forEach(b => b.classList.remove('active'));
            e.target.classList.add('active');
            // æ›´æ–°å½¢çŠ¶å˜é‡
            currentShape = e.target.dataset.shape;
        });
    });

    // 2. é¢œè‰²é€‰æ‹©
    const colorPicker = document.getElementById('color-picker');
    colorPicker.addEventListener('input', (e) => {
        const hexColor = e.target.value;
        material.color.set(hexColor);
    });

    // 3. å…¨å±æ§åˆ¶
    const fullscreenBtn = document.getElementById('fullscreen-btn');
    fullscreenBtn.addEventListener('click', () => {
        if (!document.fullscreenElement) {
            document.documentElement.requestFullscreen();
        } else {
            if (document.exitFullscreen) {
                document.exitFullscreen();
            }
        }
    });

    // çª—å£å¤§å°æ”¹å˜è‡ªé€‚åº”
    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });

</script>
</body>
</html>
