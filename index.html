<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>åœ£è¯æ ‘æŒ‚ä»¶ç›¸å†Œ</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
    <link href="https://fonts.googleapis.com/css2?family=Ma+Shan+Zheng&display=swap" rel="stylesheet">

    <style>
        body { margin: 0; overflow: hidden; background-color: #050a14; font-family: 'Segoe UI', sans-serif; }
        
        #title-overlay {
            position: absolute; width: 100%; top: 5%; text-align: center; pointer-events: none; z-index: 5;
            transition: opacity 1s;
        }
        h1 {
            font-family: 'Ma Shan Zheng', cursive; 
            color: #ffd700; 
            font-size: 5rem; 
            margin: 0;
            letter-spacing: 5px;
            text-shadow: 0 0 10px #ff0000, 0 0 20px #ffd700;
            animation: glow 3s ease-in-out infinite alternate;
        }
        @keyframes glow { from { opacity: 0.8; text-shadow: 0 0 10px #ff0000; } to { opacity: 1; text-shadow: 0 0 30px #ffd700, 0 0 50px #ff0000; } }

        #camera-container {
            position: absolute; top: 20px; left: 20px; width: 240px; height: 180px; z-index: 20;
            border-radius: 12px; overflow: hidden; border: 2px solid rgba(255, 215, 0, 0.5);
            box-shadow: 0 0 15px rgba(255, 215, 0, 0.2); transform: scaleX(-1);
            background: #000;
        }
        .input_video { position: absolute; width: 100%; height: 100%; object-fit: cover; opacity: 0.8; }
        .output_canvas { position: absolute; width: 100%; height: 100%; }

        #guide-panel {
            position: absolute; bottom: 30px; width: 100%; text-align: center; color: rgba(255,255,255,0.8); z-index: 10;
            pointer-events: none; font-size: 0.9rem;
        }
        .key { color: #ffd700; font-weight: bold; margin: 0 5px; }

        #canvas-container { width: 100%; height: 100%; position: absolute; top: 0; left: 0; }
        #loading { position: absolute; top: 50%; left: 50%; transform: translate(-50%,-50%); color: #ffd700; font-size: 1.5rem; z-index: 100; text-align: center; }
    </style>
</head>
<body>
    <div id="loading">ğŸ„ æ­£åœ¨æŒ‚è½½ç¤¼ç‰©...<br>è¯·å…è®¸æ‘„åƒå¤´æƒé™</div>

    <div id="title-overlay">
        <h1>åœ£è¯å¿«ä¹</h1>
    </div>

    <div id="camera-container">
        <video class="input_video"></video>
        <canvas class="output_canvas"></canvas>
    </div>

    <div id="guide-panel">
        <span class="key">âœŠ æ¡æ‹³</span> æ—‹è½¬å±•ç¤º &nbsp;|&nbsp; 
        <span class="key">âœ‹ å¼ å¼€</span> æ”¾å¤§æŸ¥çœ‹ &nbsp;|&nbsp; 
        <span class="key">ğŸ‘ˆ æŒ¥æ‰‹ ğŸ‘‰</span> æ§åˆ¶æ—‹è½¬ &nbsp;|&nbsp; 
        <span class="key">ğŸ‘Œ æåˆ</span> é€‰ä¸­ç…§ç‰‡
    </div>

    <div id="canvas-container"></div>

<script>
    // ================= é…ç½®åŒºåŸŸ =================
    const PARTICLE_COUNT = 6000; 
    
    // å›¾ç‰‡è·¯å¾„ (ç¡®ä¿æ–‡ä»¶åæ­£ç¡®)
    const IMG_URL = './4c8e14a7eeee433eb7dfcb541fd2b6e8_1.jpg';
    // å¤åˆ¶6ä»½ï¼ŒæŒ‚åœ¨æ ‘çš„ä¸åŒé«˜åº¦å’Œè§’åº¦
    const PHOTOS = [IMG_URL, IMG_URL, IMG_URL, IMG_URL, IMG_URL, IMG_URL];
    
    // ================= åœºæ™¯åˆå§‹åŒ– =================
    const scene = new THREE.Scene();
    // ä½¿ç”¨æ›´æ·±çš„é›¾ï¼Œçªå‡ºå‰æ™¯
    scene.fog = new THREE.FogExp2(0x050a14, 0.02);
    
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.z = 8;
    camera.position.y = 0; 

    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    document.getElementById('canvas-container').appendChild(renderer.domElement);

    // åˆ›å»ºä¸€ä¸ªåŒ…å«æ ‘å’Œç…§ç‰‡çš„æ•´ä½“ç»„ï¼Œæ–¹ä¾¿ä¸€èµ·æ—‹è½¬
    const christmasGroup = new THREE.Group();
    scene.add(christmasGroup);

    // ================= 1. ç²’å­åœ£è¯æ ‘ (æ›´ç²—å£®ã€æ›´äº®) =================
    const particlesGeometry = new THREE.BufferGeometry();
    const particlesPositions = new Float32Array(PARTICLE_COUNT * 3);
    const particlesColors = new Float32Array(PARTICLE_COUNT * 3);
    const particlesSizes = new Float32Array(PARTICLE_COUNT);
    
    // è®°å½•æ¯ä¸ªç²’å­åœ¨æ ‘ä¸Šçš„åŸå§‹ä½ç½®
    const treeOriginalPos = new Float32Array(PARTICLE_COUNT * 3);
    
    const colorGreen = new THREE.Color('#27ae60'); // æ›´é²œè‰³çš„ç»¿
    const colorRed = new THREE.Color('#c0392b');
    const colorGold = new THREE.Color('#f1c40f');

    for (let i = 0; i < PARTICLE_COUNT; i++) {
        const i3 = i * 3;
        
        // èºæ—‹åœ†é”¥ç®—æ³•
        const t = i / PARTICLE_COUNT; 
        const angle = t * 50; // èºæ—‹åœˆæ•°
        
        // yä»ä¸‹åˆ°ä¸Šï¼š-4 åˆ° 3
        const y = (t * 7) - 4; 
        // åŠå¾„ï¼šåº•éƒ¨å®½(3.5)ï¼Œé¡¶éƒ¨å°–(0)
        const maxRadius = (1 - t) * 3.5; 
        // éšæœºå¡«å……åŠå¾„å†…éƒ¨ï¼Œè®©æ ‘æœ‰åšåº¦
        const r = Math.random() * maxRadius; 
        
        const x = r * Math.cos(angle);
        const z = r * Math.sin(angle);

        // å­˜å…¥åŸå§‹ä½ç½®
        treeOriginalPos[i3] = x;
        treeOriginalPos[i3+1] = y;
        treeOriginalPos[i3+2] = z;

        // åˆå§‹åŒ–ä½ç½®
        particlesPositions[i3] = x;
        particlesPositions[i3+1] = y;
        particlesPositions[i3+2] = z;

        // é¢œè‰²é€»è¾‘
        let color = colorGreen;
        let size = 0.06; 
        
        // å¢åŠ è£…é¥°å¯†åº¦
        if (Math.random() > 0.85) { color = colorRed; size = 0.12; } 
        if (Math.random() > 0.90) { color = colorGold; size = 0.15; } 
        
        particlesColors[i3] = color.r;
        particlesColors[i3+1] = color.g;
        particlesColors[i3+2] = color.b;
        particlesSizes[i] = size;
    }

    particlesGeometry.setAttribute('position', new THREE.BufferAttribute(particlesPositions, 3));
    particlesGeometry.setAttribute('color', new THREE.BufferAttribute(particlesColors, 3));
    particlesGeometry.setAttribute('size', new THREE.BufferAttribute(particlesSizes, 1));

    // ä½¿ç”¨ Shader å®ç°æ›´äº®çš„é—ªçƒç‚¹
    const particleMaterial = new THREE.ShaderMaterial({
        uniforms: {
            time: { value: 0 },
            pointTexture: { value: new THREE.TextureLoader().load("https://assets.codepen.io/127738/dotTexture.png") }
        },
        vertexShader: `
            attribute float size;
            varying vec3 vColor;
            uniform float time;
            void main() {
                vColor = color;
                vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                // é—ªçƒé€Ÿåº¦åŠ å¿«ï¼Œå¹…åº¦åŠ å¤§
                float blink = 0.8 + 0.4 * sin(time * 4.0 + position.y * 3.0 + position.x);
                gl_PointSize = size * (300.0 / -mvPosition.z) * blink;
                gl_Position = projectionMatrix * mvPosition;
            }
        `,
        fragmentShader: `
            uniform sampler2D pointTexture;
            varying vec3 vColor;
            void main() {
                gl_FragColor = vec4(vColor, 1.0);
                gl_FragColor = gl_FragColor * texture2D(pointTexture, gl_PointCoord);
                if (gl_FragColor.a < 0.1) discard; // å‰”é™¤é€æ˜åƒç´ 
            }
        `,
        blending: THREE.AdditiveBlending,
        depthTest: false,
        transparent: true
    });

    const particleSystem = new THREE.Points(particlesGeometry, particleMaterial);
    christmasGroup.add(particleSystem); // åŠ åˆ°ç»„é‡Œ

    // ================= 2. æŒ‚ä»¶ç…§ç‰‡ (èºæ—‹æ’åˆ—åœ¨æ ‘ä¸Š) =================
    const photoMeshes = [];
    const textureLoader = new THREE.TextureLoader();
    
    PHOTOS.forEach((url, index) => {
        textureLoader.load(url, (texture) => {
            const geometry = new THREE.PlaneGeometry(1.2, 1.6); // ç…§ç‰‡æ¯”ä¾‹
            // ç»™ç…§ç‰‡åŠ ä¸ªé‡‘è¾¹æè´¨ï¼Œçœ‹èµ·æ¥åƒå¡ç‰‡
            const material = new THREE.MeshBasicMaterial({ 
                map: texture, 
                side: THREE.DoubleSide,
            });
            const mesh = new THREE.Mesh(geometry, material);
            
            // --- å…³é”®ï¼šè®¡ç®—æŒ‚åœ¨æ ‘ä¸Šçš„ä½ç½® ---
            // å°†ç…§ç‰‡å‡åŒ€åˆ†å¸ƒåœ¨èºæ—‹çº¿ä¸Šï¼Œä»ä¸‹å¾€ä¸Š
            const t = index / PHOTOS.length; // 0 ~ 1
            const y = (t * 5) - 2.5; // é«˜åº¦åˆ†å¸ƒ -2.5 åˆ° 2.5
            // åŠå¾„æ ¹æ®é«˜åº¦ç®—å‡ºæ ‘çš„è¡¨é¢ä½ç½® (ç¨å¾®å‘å¤–ä¸€ç‚¹ç‚¹ï¼Œä»¥å…è¢«ç²’å­åŸ‹æ²¡)
            const r = (1 - (y + 4)/7) * 3.5 + 0.5; 
            const angle = index * (Math.PI * 2 / 3); // æ¯å¼ ç…§ç‰‡è½¬ 120åº¦ï¼Œèºæ—‹ä¸Šå‡

            const x = r * Math.cos(angle);
            const z = r * Math.sin(angle);

            mesh.position.set(x, y, z);
            
            // è®©ç…§ç‰‡é¢å‘å¤–éƒ¨
            mesh.lookAt(x * 2, y, z * 2);

            // å­˜ä¸€ä¸‹â€œæŒ‚åœ¨æ ‘ä¸Šâ€çš„çŠ¶æ€æ•°æ®
            mesh.userData = {
                treePos: new THREE.Vector3(x, y, z),
                treeScale: new THREE.Vector3(0.4, 0.4, 0.4), // é»˜è®¤å¾ˆå°ï¼ŒåƒæŒ‚ä»¶
                galleryPos: new THREE.Vector3(x * 2.5, y * 0.5, z * 2.5), // ç‚¸å¼€åçš„ä½ç½®
                galleryScale: new THREE.Vector3(1.2, 1.2, 1.2) // ç‚¸å¼€åå˜å¤§
            };
            
            // åˆå§‹çŠ¶æ€
            mesh.scale.copy(mesh.userData.treeScale);

            christmasGroup.add(mesh);
            photoMeshes.push(mesh);
        });
    });

    // ================= 3. ç¯å¢ƒæ°›å›´ (é£˜é›ª) =================
    const snowGeo = new THREE.BufferGeometry();
    const snowCount = 1000;
    const snowPos = new Float32Array(snowCount * 3);
    for(let i=0; i<snowCount*3; i++) {
        snowPos[i] = (Math.random()-0.5) * 20;
    }
    snowGeo.setAttribute('position', new THREE.BufferAttribute(snowPos, 3));
    const snowMat = new THREE.PointsMaterial({color: 0xffffff, size: 0.05, transparent: true, opacity: 0.5});
    const snowSystem = new THREE.Points(snowGeo, snowMat);
    scene.add(snowSystem); // é›ªæ˜¯å…¨å±€çš„ï¼Œä¸éšæ ‘è½¬

    // ================= æ‰‹åŠ¿è¯†åˆ« =================
    let handOpenness = 0; 
    let handX = 0.5;      
    let isPinching = false; 

    const videoElement = document.getElementsByClassName('input_video')[0];
    const canvasElement = document.getElementsByClassName('output_canvas')[0];
    const canvasCtx = canvasElement.getContext('2d');

    function onResults(results) {
        document.getElementById('loading').style.display = 'none';
        canvasElement.width = videoElement.videoWidth;
        canvasElement.height = videoElement.videoHeight;
        canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);

        if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
            const landmarks = results.multiHandLandmarks[0];
            
            drawConnectors(canvasCtx, landmarks, HAND_CONNECTIONS, {color: '#00FF00', lineWidth: 2});
            drawLandmarks(canvasCtx, landmarks, {color: '#FF0000', lineWidth: 1, radius: 2});

            // å¼€åˆåº¦
            const wrist = landmarks[0];
            const tips = [8, 12, 16, 20];
            let dist = 0;
            tips.forEach(i => dist += Math.hypot(landmarks[i].x - wrist.x, landmarks[i].y - wrist.y));
            handOpenness = Math.max(0, Math.min(1, (dist/4 - 0.15) * 3));

            // æ—‹è½¬æ§åˆ¶
            handX = landmarks[9].x; 

            // æåˆæ£€æµ‹
            const pinchDist = Math.hypot(landmarks[8].x - landmarks[4].x, landmarks[8].y - landmarks[4].y);
            isPinching = pinchDist < 0.05; 
            if(isPinching) {
                canvasCtx.beginPath();
                canvasCtx.arc(landmarks[8].x * canvasElement.width, landmarks[8].y * canvasElement.height, 15, 0, 2*Math.PI);
                canvasCtx.fillStyle = "rgba(255, 215, 0, 0.5)";
                canvasCtx.fill();
            }

        } else {
            // æ— æ‰‹åŠ¿ï¼Œæ…¢æ…¢é—­åˆ
            handOpenness *= 0.9;
        }
    }

    const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
    hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });
    hands.onResults(onResults);

    const cameraUtils = new Camera(videoElement, {
        onFrame: async () => { await hands.send({image: videoElement}); },
        width: 320, height: 240
    });
    cameraUtils.start();

    // ================= åŠ¨ç”»å¾ªç¯ =================
    let smoothedOpenness = 0;
    
    function animate() {
        requestAnimationFrame(animate);

        const time = Date.now() * 0.001;
        particleMaterial.uniforms.time.value = time;
        
        smoothedOpenness += (handOpenness - smoothedOpenness) * 0.1;

        // --- 1. åœ£è¯æ ‘ç²’å­åŠ¨ç”» ---
        const positions = particleSystem.geometry.attributes.position.array;
        
        // å¦‚æœæ‰‹å¼ å¼€ï¼Œç²’å­ç‚¸å¼€
        const explosionFactor = smoothedOpenness * 4.0; 

        for (let i = 0; i < PARTICLE_COUNT; i++) {
            const i3 = i * 3;
            // åŸå§‹ä½ç½®
            const ox = treeOriginalPos[i3];
            const oy = treeOriginalPos[i3+1];
            const oz = treeOriginalPos[i3+2];

            // ç›®æ ‡ä½ç½®ï¼šåŸå§‹ä½ç½® + å‘å¤–æ‰©æ•£å‘é‡
            // ç®€å•çš„å‘å¤–æ‰©æ•£ï¼šx*factor, z*factor
            const tx = ox + ox * explosionFactor;
            const ty = oy + oy * explosionFactor * 0.5; // é«˜åº¦æ‰©æ•£å°‘ä¸€ç‚¹
            const tz = oz + oz * explosionFactor;

            // æ’å€¼æ›´æ–°
            positions[i3] += (tx - positions[i3]) * 0.1;
            positions[i3+1] += (ty - positions[i3+1]) * 0.1;
            positions[i3+2] += (tz - positions[i3+2]) * 0.1;
        }
        particleSystem.geometry.attributes.position.needsUpdate = true;

        // --- 2. ç…§ç‰‡æŒ‚ä»¶åŠ¨ç”» ---
        photoMeshes.forEach(mesh => {
            // ç›®æ ‡çŠ¶æ€æ’å€¼
            // 0 (æ¡æ‹³) -> ä½¿ç”¨ treePos å’Œ treeScale
            // 1 (å¼ å¼€) -> ä½¿ç”¨ galleryPos å’Œ galleryScale
            
            const targetPos = new THREE.Vector3().lerpVectors(mesh.userData.treePos, mesh.userData.galleryPos, smoothedOpenness);
            const targetScale = new THREE.Vector3().lerpVectors(mesh.userData.treeScale, mesh.userData.galleryScale, smoothedOpenness);
            
            mesh.position.lerp(targetPos, 0.1);
            mesh.scale.lerp(targetScale, 0.1);

            // æåˆé«˜äº®æ•ˆæœ (åªåœ¨å¼ å¼€çŠ¶æ€ç”Ÿæ•ˆ)
            if (smoothedOpenness > 0.5) {
                 // è®©ç…§ç‰‡å§‹ç»ˆé¢å‘æ‘„åƒæœº (å¹¿å‘Šç‰Œæ•ˆæœ) æ–¹ä¾¿æŸ¥çœ‹
                 mesh.lookAt(camera.position);
                 
                 // ç®€å•çš„é€‰ä¸­é€»è¾‘ï¼šå¦‚æœæåˆï¼Œä¸”ç…§ç‰‡åœ¨ä¸­é—´
                 // è¿™é‡Œç®€åŒ–ä¸ºï¼šæ‰€æœ‰ç…§ç‰‡æåˆæ—¶ç¨å¾®æ”¾å¤§ä¸€ç‚¹ä»¥ç¤ºåé¦ˆ
                 if (isPinching) {
                     mesh.scale.multiplyScalar(1.02);
                 }
            } else {
                // é—­åˆçŠ¶æ€ï¼šç…§ç‰‡é¢å‘å¤–éƒ¨ï¼Œåƒè´´åœ¨æ ‘ä¸Š
                mesh.lookAt(mesh.position.x * 2, mesh.position.y, mesh.position.z * 2);
            }
        });

        // --- 3. æ•´ä½“æ—‹è½¬æ§åˆ¶ ---
        if (smoothedOpenness > 0.5) {
            // å¼ å¼€æ‰‹ï¼šé€šè¿‡æ‰‹åŠ¿ä½ç½®æ§åˆ¶æ—‹è½¬
            // æ‰‹åœ¨ä¸­é—´(0.5)ä¸è½¬ï¼Œå¾€å·¦å¾€å³è½¬
            const rotateSpeed = (handX - 0.5) * 0.05;
            christmasGroup.rotation.y += rotateSpeed;
        } else {
            // æ¡æ‹³/é»˜è®¤ï¼šè‡ªåŠ¨æ—‹è½¬å±•ç¤ºç¤¼ç‰©
            christmasGroup.rotation.y += 0.005;
        }

        // --- 4. é£˜é›ª ---
        const snowP = snowSystem.geometry.attributes.position.array;
        for(let i=1; i<snowCount*3; i+=3) {
            snowP[i] -= 0.02; 
            if(snowP[i] < -10) snowP[i] = 10; 
        }
        snowSystem.geometry.attributes.position.needsUpdate = true;

        renderer.render(scene, camera);
    }
    animate();

    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });
</script>
</body>
</html>
