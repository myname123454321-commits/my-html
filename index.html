<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>åœ£è¯äº¤äº’ç›¸å†Œ</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
    <link href="https://fonts.googleapis.com/css2?family=Great+Vibes&display=swap" rel="stylesheet">

    <style>
        body { margin: 0; overflow: hidden; background-color: #02050a; font-family: 'Segoe UI', sans-serif; }
        
        /* åä¸½çš„åœ£è¯æ–‡å­— */
        #title-overlay {
            position: absolute; width: 100%; top: 10%; text-align: center; pointer-events: none; z-index: 5;
            transition: opacity 1s;
        }
        h1 {
            font-family: 'Great Vibes', cursive; color: #ffd700; font-size: 6rem; margin: 0;
            text-shadow: 0 0 10px #ff0000, 0 0 20px #ffd700, 0 0 40px #ff0000;
            animation: glow 2s ease-in-out infinite alternate;
        }
        @keyframes glow { from { text-shadow: 0 0 10px #ff0000, 0 0 20px #ffd700; } to { text-shadow: 0 0 20px #ff0000, 0 0 40px #ffd700, 0 0 60px #ff0000; } }

        /* å·¦ä¸Šè§’æ‘„åƒå¤´ */
        #camera-container {
            position: absolute; top: 20px; left: 20px; width: 240px; height: 180px; z-index: 20;
            border-radius: 12px; overflow: hidden; border: 2px solid rgba(255, 215, 0, 0.6);
            box-shadow: 0 0 15px rgba(255, 215, 0, 0.3); transform: scaleX(-1);
            background: rgba(0,0,0,0.5);
        }
        .input_video { position: absolute; width: 100%; height: 100%; object-fit: cover; opacity: 0.6; }
        .output_canvas { position: absolute; width: 100%; height: 100%; }

        /* UI æŒ‡å¼• */
        #guide-panel {
            position: absolute; bottom: 30px; width: 100%; text-align: center; color: white; z-index: 10;
            pointer-events: none; text-shadow: 0 2px 4px rgba(0,0,0,0.8);
        }
        .guide-item { display: inline-block; margin: 0 20px; background: rgba(0,0,0,0.4); padding: 10px 20px; border-radius: 20px; border: 1px solid rgba(255,255,255,0.2); }
        .key { color: #ffd700; font-weight: bold; font-size: 1.2rem; }

        #canvas-container { width: 100%; height: 100%; position: absolute; top: 0; left: 0; }
        #loading { position: absolute; top: 50%; left: 50%; transform: translate(-50%,-50%); color: #ffd700; font-size: 1.5rem; z-index: 100; text-align: center; }
    </style>
</head>
<body>
    <div id="loading">ğŸ„ æ­£åœ¨å¸ƒç½®åœ£è¯åœºæ™¯...<br>è¯·å…è®¸æ‘„åƒå¤´æƒé™</div>

    <div id="title-overlay">
        <h1>Merry Christmas</h1>
    </div>

    <div id="camera-container">
        <video class="input_video"></video>
        <canvas class="output_canvas"></canvas>
    </div>

    <div id="guide-panel">
        <div class="guide-item"><span class="key">âœŠ æ¡æ‹³</span> å¬å”¤åœ£è¯æ ‘</div>
        <div class="guide-item"><span class="key">âœ‹ å¼ å¼€</span> æ‰“å¼€ç›¸å†Œ</div>
        <div class="guide-item"><span class="key">ğŸ‘ˆ ç§»åŠ¨ ğŸ‘‰</span> æ—‹è½¬ç…§ç‰‡</div>
        <div class="guide-item"><span class="key">ğŸ‘Œ æåˆ</span> é€‰ä¸­ç…§ç‰‡</div>
    </div>

    <div id="canvas-container"></div>

<script>
    // ================= é…ç½® =================
    const PARTICLE_COUNT = 8000;
    const PHOTOS = [
        'https://picsum.photos/id/1015/400/600', // æ›¿æ¢æˆä½ è‡ªå·±çš„ç…§ç‰‡é“¾æ¥
        'https://picsum.photos/id/1016/400/600',
        'https://picsum.photos/id/1018/400/600',
        'https://picsum.photos/id/1019/400/600',
        'https://picsum.photos/id/1025/400/600',
        'https://picsum.photos/id/1035/400/600'
    ];
    
    // ================= åœºæ™¯åˆå§‹åŒ– =================
    const scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x02050a, 0.02);
    
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.z = 6;
    camera.position.y = 0.5;

    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    document.getElementById('canvas-container').appendChild(renderer.domElement);

    // ================= 1. åä¸½ç²’å­ç³»ç»Ÿ (åœ£è¯æ ‘) =================
    const particlesGeometry = new THREE.BufferGeometry();
    const particlesPositions = new Float32Array(PARTICLE_COUNT * 3);
    const particlesColors = new Float32Array(PARTICLE_COUNT * 3);
    const particlesSizes = new Float32Array(PARTICLE_COUNT);
    
    // ç›®æ ‡ä½ç½®ç¼“å­˜
    const treePositions = new Float32Array(PARTICLE_COUNT * 3);
    
    const colorGreen = new THREE.Color('#2ecc71');
    const colorRed = new THREE.Color('#e74c3c');
    const colorGold = new THREE.Color('#f1c40f');

    for (let i = 0; i < PARTICLE_COUNT; i++) {
        const i3 = i * 3;
        // è®¡ç®—æ ‘å½¢åæ ‡ (èºæ—‹åœ†é”¥)
        const t = i / PARTICLE_COUNT; 
        const angle = t * 60; 
        const radius = (1 - t) * 3 * Math.random(); 
        const y = t * 5 - 2.5;
        const x = radius * Math.cos(angle);
        const z = radius * Math.sin(angle);

        treePositions[i3] = x;
        treePositions[i3+1] = y;
        treePositions[i3+2] = z;

        // åˆå§‹ä½ç½® (ç‚¸å¼€çš„çŠ¶æ€)
        particlesPositions[i3] = (Math.random() - 0.5) * 20;
        particlesPositions[i3+1] = (Math.random() - 0.5) * 20;
        particlesPositions[i3+2] = (Math.random() - 0.5) * 20;

        // é¢œè‰²åˆ†é…ï¼šå¤§éƒ¨åˆ†ç»¿ï¼Œå°‘éƒ¨åˆ†çº¢é‡‘è£…é¥°
        let color = colorGreen;
        let size = 0.03;
        if (Math.random() > 0.8) { color = colorRed; size = 0.06; } // çº¢è‰²è£…é¥°çƒ
        if (Math.random() > 0.9) { color = colorGold; size = 0.08; } // é‡‘è‰²æ˜Ÿæ˜Ÿ
        
        particlesColors[i3] = color.r;
        particlesColors[i3+1] = color.g;
        particlesColors[i3+2] = color.b;
        particlesSizes[i] = size;
    }

    particlesGeometry.setAttribute('position', new THREE.BufferAttribute(particlesPositions, 3));
    particlesGeometry.setAttribute('color', new THREE.BufferAttribute(particlesColors, 3));
    particlesGeometry.setAttribute('size', new THREE.BufferAttribute(particlesSizes, 1));

    // è‡ªå®šä¹‰ Shader æè´¨å®ç°é—ªçƒæ•ˆæœ
    const particleMaterial = new THREE.ShaderMaterial({
        uniforms: {
            time: { value: 0 },
            pointTexture: { value: new THREE.TextureLoader().load("https://assets.codepen.io/127738/dotTexture.png") }
        },
        vertexShader: `
            attribute float size;
            varying vec3 vColor;
            uniform float time;
            void main() {
                vColor = color;
                vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                // å‘¼å¸é—ªçƒæ•ˆæœ
                float blink = 1.0 + 0.5 * sin(time * 3.0 + position.x);
                gl_PointSize = size * (300.0 / -mvPosition.z) * blink;
                gl_Position = projectionMatrix * mvPosition;
            }
        `,
        fragmentShader: `
            uniform sampler2D pointTexture;
            varying vec3 vColor;
            void main() {
                gl_FragColor = vec4(vColor, 1.0);
                gl_FragColor = gl_FragColor * texture2D(pointTexture, gl_PointCoord);
            }
        `,
        blending: THREE.AdditiveBlending,
        depthTest: false,
        transparent: true
    });

    const particleSystem = new THREE.Points(particlesGeometry, particleMaterial);
    scene.add(particleSystem);

    // ================= 2. 3D äº¤äº’ç”»å»Š (ç…§ç‰‡å¢™) =================
    const galleryGroup = new THREE.Group();
    const photoMeshes = [];
    const galleryRadius = 3.5; // ç…§ç‰‡å›´æˆçš„åŠå¾„

    const textureLoader = new THREE.TextureLoader();
    
    PHOTOS.forEach((url, index) => {
        textureLoader.load(url, (texture) => {
            const geometry = new THREE.PlaneGeometry(1.2, 1.8);
            const material = new THREE.MeshBasicMaterial({ 
                map: texture, 
                side: THREE.DoubleSide,
                transparent: true,
                opacity: 0.8
            });
            const mesh = new THREE.Mesh(geometry, material);
            
            // ç¯å½¢æ’åˆ—
            const angle = (index / PHOTOS.length) * Math.PI * 2;
            mesh.position.x = Math.cos(angle) * galleryRadius;
            mesh.position.z = Math.sin(angle) * galleryRadius;
            mesh.rotation.y = -angle + Math.PI / 2; // é¢å‘ä¸­å¿ƒ
            
            // å­˜å‚¨åŸå§‹ä½ç½®ç”¨äºå¤ä½
            mesh.userData = { 
                originalPos: mesh.position.clone(),
                originalScale: new THREE.Vector3(1, 1, 1),
                angle: angle
            };

            galleryGroup.add(mesh);
            photoMeshes.push(mesh);
        });
    });
    scene.add(galleryGroup);
    galleryGroup.visible = false; // åˆå§‹éšè—

    // ================= 3. é£˜é›ªç³»ç»Ÿ =================
    const snowGeo = new THREE.BufferGeometry();
    const snowCount = 2000;
    const snowPos = new Float32Array(snowCount * 3);
    for(let i=0; i<snowCount*3; i++) snowPos[i] = (Math.random()-0.5)*30;
    snowGeo.setAttribute('position', new THREE.BufferAttribute(snowPos, 3));
    const snowMat = new THREE.PointsMaterial({color: 0xffffff, size: 0.05, transparent: true, opacity: 0.6});
    const snowSystem = new THREE.Points(snowGeo, snowMat);
    scene.add(snowSystem);

    // ================= æ‰‹åŠ¿è¯†åˆ«é€»è¾‘ =================
    let handOpenness = 0; // 0=æ‹³, 1=å¼ 
    let handX = 0.5;      // æ‰‹åœ¨å±å¹•æ¨ªå‘ä½ç½® (0-1)
    let isPinching = false; // æ˜¯å¦æåˆ

    const videoElement = document.getElementsByClassName('input_video')[0];
    const canvasElement = document.getElementsByClassName('output_canvas')[0];
    const canvasCtx = canvasElement.getContext('2d');

    function onResults(results) {
        document.getElementById('loading').style.display = 'none';
        canvasElement.width = videoElement.videoWidth;
        canvasElement.height = videoElement.videoHeight;
        canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);

        if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
            const landmarks = results.multiHandLandmarks[0];
            
            // ç»˜åˆ¶éª¨éª¼
            drawConnectors(canvasCtx, landmarks, HAND_CONNECTIONS, {color: '#00FF00', lineWidth: 2});
            drawLandmarks(canvasCtx, landmarks, {color: '#FF0000', lineWidth: 1, radius: 2});

            // 1. è®¡ç®—æ‰‹æŒå¼€åˆåº¦
            const wrist = landmarks[0];
            const tips = [8, 12, 16, 20];
            let dist = 0;
            tips.forEach(i => {
                const dx = landmarks[i].x - wrist.x;
                const dy = landmarks[i].y - wrist.y;
                dist += Math.sqrt(dx*dx + dy*dy);
            });
            handOpenness = Math.max(0, Math.min(1, (dist/4 - 0.15) * 3));

            // 2. è·å–æ‰‹æŒæ¨ªå‘ä½ç½® (ç”¨äºæ§åˆ¶æ—‹è½¬)
            handX = landmarks[9].x; // ä¸­æŒ‡æ ¹éƒ¨ä½œä¸ºæ‰‹æŒä¸­å¿ƒ

            // 3. æ£€æµ‹æåˆ (é£ŸæŒ‡8 å’Œ æ‹‡æŒ‡4 çš„è·ç¦»)
            const dx = landmarks[8].x - landmarks[4].x;
            const dy = landmarks[8].y - landmarks[4].y;
            const pinchDist = Math.sqrt(dx*dx + dy*dy);
            isPinching = pinchDist < 0.05; // é˜ˆå€¼

            // åœ¨ç”»å¸ƒä¸Šåé¦ˆæåˆçŠ¶æ€
            if(isPinching) {
                canvasCtx.beginPath();
                canvasCtx.arc(landmarks[8].x * canvasElement.width, landmarks[8].y * canvasElement.height, 10, 0, 2*Math.PI);
                canvasCtx.fillStyle = "yellow";
                canvasCtx.fill();
            }

        } else {
            // æ— æ‰‹æ—¶ï¼Œé»˜è®¤å±•ç¤ºåœ£è¯æ ‘
            handOpenness = handOpenness * 0.9;
        }
    }

    const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
    hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });
    hands.onResults(onResults);

    const cameraUtils = new Camera(videoElement, {
        onFrame: async () => { await hands.send({image: videoElement}); },
        width: 320, height: 240
    });
    cameraUtils.start();

    // ================= åŠ¨ç”»å¾ªç¯ =================
    let smoothedOpenness = 0;
    let targetRotation = 0;

    function animate() {
        requestAnimationFrame(animate);

        const time = Date.now() * 0.001;
        particleMaterial.uniforms.time.value = time; // æ›´æ–°é—ªçƒæ—¶é—´

        // å¹³æ»‘å¼€åˆæ•°å€¼
        smoothedOpenness += (handOpenness - smoothedOpenness) * 0.08;

        const positions = particleSystem.geometry.attributes.position.array;

        // --- é€»è¾‘åˆ†æ”¯ï¼šåœ£è¯æ ‘ vs ç”»å»Š ---
        if (smoothedOpenness < 0.5) {
            // === æ¨¡å¼ï¼šåœ£è¯æ ‘ (Fist) ===
            galleryGroup.visible = false;
            document.getElementById('title-overlay').style.opacity = 1;

            // ç²’å­å›åˆ°æ ‘çš„ä½ç½®
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const i3 = i * 3;
                // ç®€å•çš„çº¿æ€§æ’å€¼å›åˆ°æ ‘å½¢
                positions[i3] += (treePositions[i3] - positions[i3]) * 0.05;
                positions[i3+1] += (treePositions[i3+1] - positions[i3+1]) * 0.05;
                positions[i3+2] += (treePositions[i3+2] - positions[i3+2]) * 0.05;
            }
            // æ ‘æ•´ä½“ç¼“æ…¢æ—‹è½¬
            particleSystem.rotation.y += 0.005;

        } else {
            // === æ¨¡å¼ï¼šç”»å»Š (Open Hand) ===
            galleryGroup.visible = true;
            document.getElementById('title-overlay').style.opacity = 0.2; // æ ‡é¢˜å˜æ·¡

            // ç²’å­å‘å¤–çˆ†ç‚¸æ‰©æ•£
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const i3 = i * 3;
                const tx = treePositions[i3] * 6.0; // ç›®æ ‡æ˜¯æ‰©å¤§6å€çš„ä½ç½®
                const ty = treePositions[i3+1] * 6.0;
                const tz = treePositions[i3+2] * 6.0;
                
                positions[i3] += (tx - positions[i3]) * 0.05;
                positions[i3+1] += (ty - positions[i3+1]) * 0.05;
                positions[i3+2] += (tz - positions[i3+2]) * 0.05;
            }
            
            // --- ç”»å»Šäº¤äº’é€»è¾‘ ---
            // 1. æ—‹è½¬ï¼šæ ¹æ®æ‰‹æŒå·¦å³ä½ç½® (handX 0-1 mapped to rotation)
            // é•œåƒé€»è¾‘ï¼šæ‰‹å¾€å·¦(ç”»é¢å³è¾¹)ï¼Œç”»å»Šå¾€å·¦è½¬
            const targetRotY = (handX - 0.5) * 4; 
            galleryGroup.rotation.y += (targetRotY - galleryGroup.rotation.y) * 0.05;

            // 2. æåˆé€‰ä¸­é€»è¾‘
            // æ‰¾åˆ°ç¦»æ‘„åƒæœºæœ€è¿‘çš„é‚£å¼ ç…§ç‰‡ (zè½´æœ€å¤§çš„)
            let closestMesh = null;
            let maxZ = -999;

            photoMeshes.forEach(mesh => {
                // è·å–meshåœ¨ä¸–ç•Œåæ ‡ç³»çš„ä½ç½®
                const worldPos = new THREE.Vector3();
                mesh.getWorldPosition(worldPos);
                
                // é‡ç½®çŠ¶æ€
                mesh.material.opacity = 0.8;
                mesh.scale.set(1, 1, 1);

                if (worldPos.z > maxZ) {
                    maxZ = worldPos.z;
                    closestMesh = mesh;
                }
            });

            // å¦‚æœæåˆï¼Œæ”¾å¤§æœ€è¿‘çš„é‚£å¼ 
            if (isPinching && closestMesh) {
                closestMesh.scale.set(1.5, 1.5, 1.5);
                closestMesh.material.opacity = 1;
            }
        }

        particleSystem.geometry.attributes.position.needsUpdate = true;

        // æ›´æ–°ä¸‹é›ª
        const snowP = snowSystem.geometry.attributes.position.array;
        for(let i=1; i<snowCount*3; i+=3) {
            snowP[i] -= 0.05; // ä¸‹è½
            if(snowP[i] < -10) snowP[i] = 10; // å¾ªç¯
        }
        snowSystem.geometry.attributes.position.needsUpdate = true;

        renderer.render(scene, camera);
    }
    animate();

    // çª—å£è‡ªé€‚åº”
    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });
</script>
</body>
</html>
